<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/22/hello-world/"/>
      <url>/2019/03/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus 查询语言</title>
      <link href="/2019/03/22/Prometheus/query/"/>
      <url>/2019/03/22/Prometheus/query/</url>
      
        <content type="html"><![CDATA[<h2 id="PromQL-语法"><a href="#PromQL-语法" class="headerlink" title="PromQL 语法"></a>PromQL 语法</h2><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>PromQL 表达式计算出来的值有以下几种类型：</p><h3 id="瞬时向量-Instant-vector"><a href="#瞬时向量-Instant-vector" class="headerlink" title="瞬时向量 (Instant vector):"></a>瞬时向量 (Instant vector):</h3><ul><li>一组时序，每个时序只有一个采样值</li><li>区间向量 (Range vector): 一组时序，每个时序包含一段时间内的多个采样值</li><li>标量数据 (Scalar): 一个浮点数</li><li>字符串 (String): 一个字符串，暂时未用<a id="more"></a><h3 id="时序选择器"><a href="#时序选择器" class="headerlink" title="时序选择器"></a>时序选择器</h3></li></ul><h3 id="瞬时向量选择器"><a href="#瞬时向量选择器" class="headerlink" title="瞬时向量选择器"></a>瞬时向量选择器</h3><p>瞬时向量选择器用来选择一组时序在某个采样点的采样值。<br>最简单的情况就是指定一个度量指标，选择出所有属于该度量指标的时序的当前采样值。比如下面的表达式：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total<br></code></pre></td></tr></table></figure><p> 可以通过在后面添加用大括号包围起来的一组标签键值对来对时序进行过滤。比如下面的表达式筛选出了 job  为 prometheus，并且 group 为 canary 的时序：</p> <figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total&#123;job=<span class="hljs-string">"prometheus"</span>, group=<span class="hljs-string">"canary"</span>&#125;<br></code></pre></td></tr></table></figure><p>匹配标签 值时可以是等于，也可以使用正则表达式。总共有下面几种匹配操作符：</p><ul><li>=：完全相等</li><li>!=: 不相等</li><li>=~: 正则表达式匹配</li><li>!~: 正则表达式不匹配<br>下面的表达式筛选出了 environment 为 staging 或 testing 或 development，并且 method 不是 GET 的时序：</li></ul><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total&#123;environment=~<span class="hljs-string">"staging|testing|development"</span>,method!=<span class="hljs-string">"GET"</span>&#125;<br></code></pre></td></tr></table></figure><p>度量指标名可以使用内部标签 <strong>name</strong> 来匹配，表达式 http_requests_total 也可以写成 {<strong>name</strong>=”http_requests_total”}。表达式 {<strong>name</strong>=~”job:.*”} </p><p>匹配所有度量指标名称以 job: 打头的时序。</p><h3 id="区间向量选择器"><a href="#区间向量选择器" class="headerlink" title="区间向量选择器"></a>区间向量选择器</h3><p>区间向量选择器类似于瞬时向量选择器，不同的是它选择的是过去一段时间的采样值。可以通过在瞬时向量选择器后面添加包含在 [] 里的时长来得到区间向量选择器。<br>比如下面的表达式选出了所有度量指标为 http_requests_total 且 job 为 prometheus 的时序在过去 5 分钟的采样值。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total&#123;job=<span class="hljs-string">"prometheus"</span>&#125;[5m]<br></code></pre></td></tr></table></figure><p>时长的单位可以是下面几种之一：</p><ul><li>s：seconds</li><li>m：minutes</li><li>h：hours</li><li>d：days</li><li>w：weeks</li><li>y：years</li></ul><h3 id="偏移修饰器"><a href="#偏移修饰器" class="headerlink" title="偏移修饰器"></a>偏移修饰器</h3><p>前面介绍的选择器默认都是以当前时间为基准时间，偏移修饰器用来调整基准时间，使其往前偏移一段时间。<br>偏移修饰器紧跟在选择器后面，使用 offset 来指定要偏移的量。</p><p>比如下面的表达式选择度量名称为 http_requests_total 的所有时序在 5 分钟前的采样值。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total offset 5m<br></code></pre></td></tr></table></figure><p>下面的表达式选择 http_requests_total 度量指标在 1 周前的这个时间点过去 5 分钟的采样值。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total[5m] offset 1w<br></code></pre></td></tr></table></figure><h2 id="PromQL-操作符"><a href="#PromQL-操作符" class="headerlink" title="PromQL 操作符"></a>PromQL 操作符</h2><h3 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符"></a>二元操作符</h3><p>PromQL 的二元操作符支持基本的逻辑和算术运算，包含算术类、比较类和逻辑类 三大类。</p><h3 id="算术类二元操作符"><a href="#算术类二元操作符" class="headerlink" title="算术类二元操作符"></a>算术类二元操作符</h3><p>算术类二元操作符有以下几种：</p><ul><li>+：加</li><li>-：减</li><li>*：乘</li><li>/：除</li><li>%：求余</li><li>^：乘方</li></ul><p>算术类二元操作符可以 使用在标量与标量、向量与标量，以及向量与向量之间。</p><p>二元操作符上下文里的向量特指瞬时向量，不包括区间向量。</p><p>标量与标量之间，结果很明显，跟通常的算术运算一致。<br>向量与标量之间，相当于把标量跟向量里的每一个标量进行运算，这些 计算结果组成了一个新的向量。</p><p>向量与向量之间，会稍微麻烦一些。<br> 运算的时候 首先会为左边向量里的每一个元素在右边向量里去寻找一个匹配元素（匹配规则后面会讲），然后 对这两个匹配元素执行计算，这样每对匹配元素的计算结果组成了一个新的向量。<br>如果没有找到匹配元素，则该元素丢弃。</p><h3 id="比较类二元操作符"><a href="#比较类二元操作符" class="headerlink" title="比较类二元操作符"></a>比较类二元操作符</h3><p>比较类二元操作符有以下几种：</p><ul><li>== (equal)</li><li>!= (not-equal)</li><li><blockquote><p>(greater-than)</p></blockquote></li><li>&lt; (less-than)</li><li><blockquote><p>= (greater-or-equal)</p></blockquote></li><li>&lt;= (less-or-equal)</li></ul><p>比较类二元操作符同样可以 使用在标量与标量、向量与标量，以及向量与向量之间。<br>默认执行的是过滤，也就是保留值。可以通过在运算符后面跟 bool 修饰符来使得返回值 0 和 1，而不是过滤。</p><p>标量与标量之间，必须跟 bool 修饰符，因此结果只可能是 0（false） 或 1（true）。<br>向量与标量之间，相当于把向量里的每一个标量跟标量进行比较，结果 为真则保留，否则丢弃。<br>如果后面跟了 bool 修饰符，则结果分别为 1 和 0。</p><p>向量与向量之间，运算过程类似于算术类操作符，只不过 如果比较结果 为真则保留左边的值（包括度量指标和标签这些属性），否则丢弃， 没找到匹配也是丢弃。<br>如果后面跟了 bool 修饰符，则保留和丢弃时结果相应为 1 和 0。</p><h3 id="逻辑类二元操作符"><a href="#逻辑类二元操作符" class="headerlink" title="逻辑类二元操作符"></a>逻辑类二元操作符</h3><p>逻辑操作符仅用于 向量与向量之间。</p><ul><li>and：交集</li><li>or：合集</li><li>unless：补集</li></ul><p>具体运算规则如下：<br>vector1 and vector2 的结果<br>由在 vector2 里有匹配（标签键值对组合相同）元素的 vector1 里的元素组成。</p><p>vector1 or vector2 的结果<br>由所有 vector1 里的元素加上在 vector1 里没有匹配（标签键值对组合相同）元素的  vector2 里的元素组成。</p><p>vector1 unless vector2 的结果<br>由在 vector2 里没有匹配（标签键值对组合相同）元素的 vector1 里的元素组成。</p><h3 id="二元操作符优先级"><a href="#二元操作符优先级" class="headerlink" title="二元操作符优先级"></a>二元操作符优先级</h3><p>PromQL 的各类二元操作符运算优先级如下：</p><ul><li>^</li><li>*, /, %</li><li>+, -</li><li>==, !=, &lt;=, &lt;, &gt;=, &gt;</li><li>and, unless</li><li>or</li></ul><h3 id="向量匹配"><a href="#向量匹配" class="headerlink" title="向量匹配"></a>向量匹配</h3><p>前面算术类和比较类操作符都需要在向量之间进行匹配。 共有两种匹配类型，one-to-one 和 many-to-one / one-to-many。</p><h3 id="One-to-one-向量匹配"><a href="#One-to-one-向量匹配" class="headerlink" title="One-to-one 向量匹配"></a>One-to-one 向量匹配</h3><p>这种匹配模式下，两边向量里的元素如果其标签键值对组合相同则为匹配，并且 只会有一个匹配 元素。可以使用 ignoring 关键词来忽略不参与匹配的标签，或者使用 on 关键词来指定要参与匹配的标签。语法如下：</p><p><vector expr> <bin-op> ignoring(<label list>) <vector expr></vector></label></bin-op></vector></p><p><vector expr> <bin-op> on(<label list>) <vector expr></vector></label></bin-op></vector></p><p>比如对于下面的输入：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">method_code:http_errors:rate5m&#123;method=<span class="hljs-string">"get"</span>, code=<span class="hljs-string">"500"</span>&#125;  24<br>method_code:http_errors:rate5m&#123;method=<span class="hljs-string">"get"</span>, code=<span class="hljs-string">"404"</span>&#125;  30<br>method_code:http_errors:rate5m&#123;method=<span class="hljs-string">"put"</span>, code=<span class="hljs-string">"501"</span>&#125;  3<br>method_code:http_errors:rate5m&#123;method=<span class="hljs-string">"post"</span>, code=<span class="hljs-string">"500"</span>&#125; 6<br>method_code:http_errors:rate5m&#123;method=<span class="hljs-string">"post"</span>, code=<span class="hljs-string">"404"</span>&#125; 21<br><br>method:http_requests:rate5m&#123;method=<span class="hljs-string">"get"</span>&#125;  600<br>method:http_requests:rate5m&#123;method=<span class="hljs-string">"del"</span>&#125;  34<br>method:http_requests:rate5m&#123;method=<span class="hljs-string">"post"</span>&#125; 120<br></code></pre></td></tr></table></figure><p>执行下面的查询：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">method_code:http_errors:rate5m&#123;code=<span class="hljs-string">"500"</span>&#125; / ignoring(code) method:http_requests:rate5m<br></code></pre></td></tr></table></figure><p>得到的结果为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;method=<span class="hljs-string">"get"</span>&#125;  0.04            //  24 / 600<br>&#123;method=<span class="hljs-string">"post"</span>&#125; 0.05            //   6 / 120<br></code></pre></td></tr></table></figure><p>也就是每一种 method 里 code 为 500 的请求数占总数的百分比。由于 method 为 put 和 del 的没有匹配元素所以没有出现在结果里。</p><p>Many-to- one / one-to-many 向量匹配<br>这种匹配模式下，某一边会有多个元素跟另一边的元素匹配。这时就需要使用 group_left 或 group_right 组修饰符来指明哪边匹配元素较多，左边多则用 group_left，右边多则用 group_right。其语法如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;<br>&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;<br>&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;<br>&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;<br></code></pre></td></tr></table></figure><p>组修饰符只适用于算术类和比较类操作符。</p><p>对于前面的输入，执行下面的查询：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m<br></code></pre></td></tr></table></figure><p>将得到下面的结果：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;method=<span class="hljs-string">"get"</span>, code=<span class="hljs-string">"500"</span>&#125;  0.04            //  24 / 600<br>&#123;method=<span class="hljs-string">"get"</span>, code=<span class="hljs-string">"404"</span>&#125;  0.05            //  30 / 600<br>&#123;method=<span class="hljs-string">"post"</span>, code=<span class="hljs-string">"500"</span>&#125; 0.05            //   6 / 120<br>&#123;method=<span class="hljs-string">"post"</span>, code=<span class="hljs-string">"404"</span>&#125; 0.175           //  21 / 120<br></code></pre></td></tr></table></figure><p>也就是每种 method 的每种 code  错误次数占每种 method 请求数的比例。这里匹配的时候 ignoring 了 code，才使得两边可以形成 Many-to- one 形式的匹配。 由于左边多，所以需要使用 group_left 来指明。</p><p>Many-to- one / one-to-many 过于高级和复杂，要尽量避免使用。很多时候通过 ignoring 就可以解决问题。</p><h3 id="聚合操作符"><a href="#聚合操作符" class="headerlink" title="聚合操作符"></a>聚合操作符</h3><p>PromQL 的聚合操作符用来将向量里的元素聚合得 更少。总共有下面这些聚合操作符：</p><ul><li>sum：求和</li><li>min：最小值</li><li>max：最大值</li><li>avg：平均值</li><li>stddev：标准差</li><li>stdvar：方差</li><li>count： 元素个数</li><li>count_values：等于某值的元素个数</li><li>bottomk：最小的 k 个元素</li><li>topk：最大的 k 个元素</li><li>quantile：分位数</li></ul><p>聚合操作符语法如下：</p><p><aggr-op>([parameter,] <vector expression>) [without|by (<label list>)]<br>其中 without 用来指定不需要保留的标签（也就是这些标签的多个值会被聚合），而 by 正好相反，用来指定需要保留的标签（也就是按这些标签来聚合）。</label></vector></aggr-op></p><p>下面来看几个示例：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sum(http_requests_total) without (instance)<br></code></pre></td></tr></table></figure><p>http_requests_total 度量指标带有 application、instance  和 group 三个标签。上面的表达式会得到每个 application 的 每个 group 在所有 instance 上的请求总数。 效果等同于下面的表达式：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sum(http_requests_total) by (application, group)<br></code></pre></td></tr></table></figure><p>下面的表达式可以得到所有 application 的所有 group 的所有 instance 的请求总数。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sum(http_requests_total)<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Prometheus 内置了一些函数来辅助计算，下面介绍一些典型的，完整的列表请参考 官方文档。</p><ul><li>abs()：绝对值</li><li>sqrt()：平方根</li><li>exp()：指数计算</li><li>ln()：自然对数</li><li>ceil()：向上取整</li><li>floor()：向下 取整</li><li>round()：四舍五入取整</li><li>delta()：计算区间向量里每一个时序第一个和最后一个的差值</li><li>sort()：排序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 监控 </category>
          
          <category> Prometheus </category>
          
          <category> PromQL查询 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus 安装配置和使用</title>
      <link href="/2019/03/22/Prometheus/install/"/>
      <url>/2019/03/22/Prometheus/install/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="二进制安装包方式"><a href="#二进制安装包方式" class="headerlink" title="二进制安装包方式"></a>二进制安装包方式</h3><p>二进制安装包方式非常简单，实验环境里推荐使用这种方式。首先下载安装包 prometheus-2.2.1.linux-amd64.tar.gz（实验楼提供的是 64 位 Linux 平台的安装包，其它平台可从 官网 下载），然后解压即可。<br><a id="more"></a><br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget http://labfile.oss.aliyuncs.com/courses/1102/prometheus-2.2.1.linux-amd64.tar.gz<br>$ tar xvfz prometheus-2.2.1.linux-amd64.tar.gz<br>$ <span class="hljs-built_in">cd</span> prometheus-2.2.1.linux-amd64<br>$ ./prometheus<br></code></pre></td></tr></table></figure></p><p>上面的命令会在默认的 9090 端口启动 Prometheus 服务，打开地址 <a href="http://localhost:9090/" target="_blank" rel="noopener">http://localhost:9090/</a> 即可看到其  Web 界面。</p><h3 id="源码方式"><a href="#源码方式" class="headerlink" title="源码方式"></a>源码方式</h3><p>Prometheus 是开源的， 因此可以下载源码到本地来编译安装。这种方式比较麻烦，适合想学习源码或做二次开发的人。感兴趣的同学可以自行研究，这里就不做讲解了。</p><h3 id="Docker-方式"><a href="#Docker-方式" class="headerlink" title="Docker 方式"></a>Docker 方式</h3><p>如果当前部署环境支持 Docker，那么可以采取 Docker 方式来运行 Prometheus 服务。使用下面的命令来启动一个 Prometheus 容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -p 9090:9090 prom/prometheus<br></code></pre></td></tr></table></figure><p>上面 把容器内的 9090 端口映射到了宿主机的 9090 端口，因此可以在宿主机上通过 <a href="http://localhost:9090/" target="_blank" rel="noopener">http://localhost:9090/</a> 来访问容器内的 Prometheus 服务。<br>Docker 的使用后面会有 一系列专门的实验来讲解，不熟悉的同学可以先跳过。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>执行 prometheus 命令的时候可以通过参数 –config.file 来指定配置文件路径， 默认 会使用同目录下的 prometheus.yml 文件。Prometheus 服务运行过程中如果配置文件有改动，可以给服务进程发送 SIGHUP 信号来通知服务进程重新从磁盘加载配置。这样无需重启，可以避免中断服务。</p><p>下面会逐一讲解 Prometheus 的核心配置，示例中用到的各种占位符包括：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">\&lt;boolean&gt;:  布尔值，<span class="hljs-literal">true</span> 或 <span class="hljs-literal">false</span><br>\&lt;duration&gt;: 持续时间，格式符合正则表达式 [0-9]+(ms|[smhdwy])<br>\&lt;labelname&gt;: 标签名，格式符合正则表达式 [a-zA-Z_][a-zA-Z0-9_]*<br>\&lt;labelvalue&gt;:  标签值，可以包含任意 unicode 字符<br>\&lt;filename&gt;: 文件名，任意有效的文件路径<br>\&lt;host&gt;: 主机，可以是主机名或 IP，后面可跟端口号<br>\&lt;path&gt;: URL 路径<br>\&lt;scheme&gt;: 协议，http 或 https<br>\&lt;string&gt;: 字符串<br>\&lt;secret&gt;: 密钥，比如密码<br>\&lt;tmpl_string&gt;: 模板字符串，里面包含需要展开的变量<br></code></pre></td></tr></table></figure><p>配置文件格式为 YAML，下面是一个配置文件示例：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">global:<br>  <span class="hljs-comment"># 抓取间隔，默认为 1m</span><br>  [ scrape_interval: &lt;duration&gt; | default = 1m ]<br><br>  <span class="hljs-comment"># 抓取超时时间，默认为 10s</span><br>  [ scrape_timeout: &lt;duration&gt; | default = 10s ]<br><br>  <span class="hljs-comment"># 规则评估间隔，默认为 1m</span><br>  [ evaluation_interval: &lt;duration&gt; | default = 1m ]<br><br><span class="hljs-comment"># 抓取配置</span><br>scrape_configs:<br>  [ - &lt;scrape_config&gt; ... ]<br><br><span class="hljs-comment">#  规则配置</span><br>rule_files:<br>  [ - &lt;filepath_glob&gt; ... ]<br><br><span class="hljs-comment"># 告警配置</span><br>alerting:<br>  alert_relabel_configs:<br>    [ - &lt;relabel_config&gt; ... ]<br>  alertmanagers:<br>    [ - &lt;alertmanager_config&gt; ... ]<br></code></pre></td></tr></table></figure></p><p><strong> global </strong><br>全局配置节点下的配置对所有其它节点都有效，同时也是其它节点的默认值。</p><p><strong> rule_files </strong><br>规则配置包含 记录规则配置和告警规则配置，节点下 只是列出文件，具体配置在各个文件中。<br>记录规则配置接下来会讲， 告警规则配置 在后面的告警实验中会讲解。</p><p><strong> alerting  </strong><br>告警配置 用于 Alertmanager，在告警实验中会讲解。</p><h3 id="抓取配置"><a href="#抓取配置" class="headerlink" title="抓取配置"></a>抓取配置</h3><p>抓取配置可以有多个，一般来说每个任务（Job）对应一个配置。单个抓取配置的格式如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 任务名</span><br>job_name: &lt;job_name&gt;<br><br><span class="hljs-comment"># 抓取间隔，默认为对应全局配置</span><br>[ scrape_interval: &lt;duration&gt; | default = &lt;global_config.scrape_interval&gt; ]<br><br><span class="hljs-comment"># 抓取超时时间，默认为对应全局配置</span><br>[ scrape_timeout: &lt;duration&gt; | default = &lt;global_config.scrape_timeout&gt; ]<br><br><span class="hljs-comment"># 协议，默认为 http，可选 https</span><br>[ scheme: &lt;scheme&gt; | default = http ]<br><br><span class="hljs-comment"># 抓取地址的 路径，默认为 /metrics</span><br>[ metrics_path: &lt;path&gt; | default = /metrics ]<br><br><span class="hljs-comment"># 抓取地址的参数</span><br>params:<br>  [ &lt;string&gt;: [&lt;string&gt;, ...] ]<br><br><span class="hljs-comment"># 是否尊重抓取回来的标签，默认为 false</span><br>[ honor_labels: &lt;boolean&gt; | default = <span class="hljs-literal">false</span> ]<br><br><span class="hljs-comment"># 静态目标配置</span><br>static_configs:<br>  [ - &lt;static_config&gt; ... ]<br><br><span class="hljs-comment"># 单次抓取的采样值个数限制，默认为 0，表示没有限制</span><br>[ sample_limit: &lt;int&gt; | default = 0 ]<br>honor_labels 表示是否尊重抓取回来的标签。当抓取回来的采样值的标签值跟服务端配置的不一致时，如果该配置为 <span class="hljs-literal">true</span>，则以抓取回来的为准。否则以服务端的为准，抓取回来的值会保存到一个新标签下，该新标签 名在原来的前面加上了“exported_”，比如 exported_job。<br><br>static_configs 下配置了该任务要抓取的所有实例，  按组 配置，包含相同标签的实例可以分为一组， 以简化配置。单个组的配置格式如下：<br><br><span class="hljs-comment">#  目标地址列表，地址由主机+端口 组成</span><br>targets:<br>  [ - <span class="hljs-string">'&lt;host&gt;'</span> ]<br><br><span class="hljs-comment"># 标签列表</span><br>labels:<br>  [ &lt;labelname&gt;: &lt;labelvalue&gt; ... ]<br></code></pre></td></tr></table></figure><p>抓取目标除了采用静态配置方式，还可以动态发现。动态发现依赖于一个服务发现服务（比如 Consul，可以从这个服务里查询到目前系统里的服务列表），适合监控 目标非常多并且经常变化的场景。 因为使用场景比较少，在以后需要的时候大家可以去进一步研究。</p><h3 id="记录规则配置"><a href="#记录规则配置" class="headerlink" title="记录规则配置"></a>记录规则配置</h3><p>记录规则允许我们把一些经常需要使用并且查询时计算量很大的查询表达式，预先计算并保存到一个新的时序。查询这个新的时序比 从原始一个或多个时序实时计算快得多，并且还能够避免不必要的计算。在一些特殊场景下这甚至是必须的，比如仪表盘里展示的各类定时刷新的数据，数据种类多且需要计算非常快。</p><p>记录规则配置文件的格式如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash">groups:<br>  [ - &lt;rule_group&gt; ]<br>记录规则配置按组来组织，一个组下的所有规则按顺序定时执行。单个组的格式如下：<br><br><span class="hljs-comment"># 组名，在文件内唯一</span><br>name: &lt;string&gt;<br><br><span class="hljs-comment"># 规则评估间隔，默认为对应的全局配置</span><br>[ interval: &lt;duration&gt; | default = global.evaluation_interval ]<br><br>rules:<br>  [ - &lt;rule&gt; ... ]<br>每个组下包含多条规则，格式如下：<br><br><span class="hljs-comment"># 规则名称，也就是该规则产生的时序数据的度量指标名</span><br>record: &lt;string&gt;<br><br><span class="hljs-comment"># PromQL 查询表达式，表示如何 得到采样值</span><br>expr: &lt;string&gt;<br><br><span class="hljs-comment"># 关联标签</span><br>labels:<br>  [ &lt;labelname&gt;: &lt;labelvalue&gt; ]<br>使用<br>学会安装和配置之后，接下来我们通过使用 Prometheus 监控其自身来学习 它的基本用法。<br><br>配置 Prometheus 监控其自身<br>Prometheus 服务本身也通过路径 /metrics 暴露了其内部的各项度量指标，我么只需要把它加入到监控目标里就可以。<br><br>global:<br>  <span class="hljs-comment"># 全局默认抓取间隔</span><br>  scrape_interval: 15s<br><br>scrape_configs:<br>  <span class="hljs-comment"># 任务名</span><br>  - job_name: <span class="hljs-string">'prometheus'</span><br><br>    <span class="hljs-comment">#  本任务的抓取间隔，覆盖全局配置</span><br>    scrape_interval: 5s<br><br>    static_configs:<br>      <span class="hljs-comment"># 抓取地址同  Prometheus 服务地址，路径为默认的 /metrics</span><br>      - targets: [<span class="hljs-string">'localhost:9090'</span>]<br>配置完成后启动服务：<br>$ ./prometheus<br></code></pre></td></tr></table></figure><p>可打开地址 <a href="http://localhost:9090/metrics" target="_blank" rel="noopener">http://localhost:9090/metrics</a> 来确认是否有抓取到数据。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 监控 </category>
          
          <category> Prometheus </category>
          
          <category> 安装 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus 介绍</title>
      <link href="/2019/03/22/Prometheus/recommend/"/>
      <url>/2019/03/22/Prometheus/recommend/</url>
      
        <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Prometheus（简称 Prom） 是新一代的监控系统，配置简单却灵活，对容器、微服务等支持良好。本次实验我们先来了解一下 Prometheus 的基础概念。</p><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>Prometheus总览</li><li>Prometheus核心概念<a id="more"></a></li></ol><hr><h2 id="Prometheus总览"><a href="#Prometheus总览" class="headerlink" title="Prometheus总览"></a>Prometheus总览</h2><hr><p>Prometheus 是一个开源监控系统，它前身是 SoundCloud 的告警工具包。从 2012 年开始，许多公司和组织开始使用 Prometheus。该项目的开发人员和用户社区非常活跃，越来越多的开发人员和用户参与到该项目中。目前它是一个独立的开源项目，且不依赖于任何公司。为了强调这点和明确该项目治理结构，Prometheus 在 2016 年继Kurberntes 之后，加入了 Cloud Native Computing Foundation。</p><hr><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><hr><ul><li>多维度数据模型</li><li>灵活的查询语言</li><li>不依赖任何分布式存储</li><li>常见方式是通过拉取方式采集数据</li><li>也可通过中间网关支持推送方式采集数据</li><li>通过服务发现或者静态配置来发现监控目标</li><li>支持多种图形界面展示方式</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><hr><p>下面这张图描述了 Prometheus 的整体架构，以及其生态中的一些常用组件。</p><p><img src="/images/wm.png" alt></p><p>Prometheus Server  采用拉取方式从监控目标直接拉取数据，或者通过中间网关间接地拉取监控目标推送给 网关的数据。它在本地存储抓取的数据，通过一定规则进行清理和整理数据，然后把得到的结果存储起来。各种 Web UI 使用 PromQL 查询语言来从 Server 里获取数据。当 Server 监测到有异常时会推送告警给 Alertmanager， Alertmanager 负责去通知相关人。</p><h2 id="Prometheus-核心概念"><a href="#Prometheus-核心概念" class="headerlink" title="Prometheus 核心概念"></a>Prometheus 核心概念</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Prometheus 从根本上存储的所有数据都是时间序列数据（Time Serie Data，简称时序数据）。时序数据是具有时间戳的数据流，该数据流属于某个度量指标（Metric）和该度量指标下的多个标签（Label）。除了提供存储功能，Prometheus 还可以利用查询表达式来执行非常 灵活和复杂的查询。</p><h3 id="度量指标和标签"><a href="#度量指标和标签" class="headerlink" title="度量指标和标签"></a>度量指标和标签</h3><p>每个时间序列（Time Serie，简称时序）由度量指标和一组标签键值对唯一确定。</p><p>度量指标名称描述了被监控系统的某个测量特征（比如 http_requests_total 表示 http 请求总数）。度量指标名称由 ASCII 字母、数字、下划线和冒号组成，须匹配正则表达式 [a-zA-Z_:][a-zA-Z0-9_:]*。</p><p>标签开启了 Prometheus 的多维数据模型。对于同一个度量指标，不同标签值组合会形成特定维度的时序。Prometheus 的查询语言可以通过度量指标和标签对时序数据进行过滤和聚合。改变任何度量指标上的任何标签值，都会形成新的时序。标签名称可以包含 ASCII 字母、数字和下划线，须匹配正则表达式 [a-zA-Z_][a-zA-Z0-9_]*，带有 _ 下划线的标签名称保留为内部使用。标签值可以包含任意 Unicode 字符，包括中文。</p><h3 id="采样值（Sample）"><a href="#采样值（Sample）" class="headerlink" title="采样值（Sample）"></a>采样值（Sample）</h3><p>时序数据其实就是一系列采样值。每个采样值包括：</p><ul><li>一个 64 位的浮点数值</li><li>一个精确到毫秒的时间戳</li></ul><h3 id="注解（Notation）"><a href="#注解（Notation）" class="headerlink" title="注解（Notation）"></a>注解（Notation）</h3><p>一个注解由一个度量指标和一组标签键值对构成。形式如下：</p><p>[metric name]{[label name]=[label value], …}<br>例如，度量指标为 api_http_requests_total，标签为 method=”POST”、handler=”/messages” 的注解表示如下：</p><p>api_http_requests_total{method=”POST”, handler=”/messages”}</p><h3 id="度量指标类型"><a href="#度量指标类型" class="headerlink" title="度量指标类型"></a>度量指标类型</h3><p>Prometheus 里的度量指标有以下几种类型。</p><h4 id="计数器（Counter）"><a href="#计数器（Counter）" class="headerlink" title="计数器（Counter）"></a>计数器（Counter）</h4><p>计数器是一种累计 型的度量指标，它是一个只能递增的数值。计数器主要用于统计类似于服务请求数、任务完成数和错误出现次数这样的数据。</p><h4 id="计量器（Gauge）"><a href="#计量器（Gauge）" class="headerlink" title="计量器（Gauge）"></a>计量器（Gauge）</h4><p>计量器表示一个既可以增加, 又可以减少的度量指标值。计量器主要用于测量类似于温度、内存使用量这样的瞬时数据。</p><h4 id="直方图（Histogram）"><a href="#直方图（Histogram）" class="headerlink" title="直方图（Histogram）"></a>直方图（Histogram）</h4><p>直方图对观察结果（通常是请求持续时间或者响应大小这样的数据）进行采样，并在可配置的桶中对其进行统计。有以下几种方式来产生直方图（假设度量指标为 \<basename>）：</basename></p><p>按桶计数，相当于 <basename>_bucket{le=”<upper inclusive bound>“}<br>采样值总和，相当于 <basename>_sum<br>采样值总数，相当于 <basename>_count ，也等同于把所有采样值放到一个桶里来计数 <basename>_bucket{le=”+Inf”}</basename></basename></basename></upper></basename></p><h4 id="汇总（Summary）"><a href="#汇总（Summary）" class="headerlink" title="汇总（Summary）"></a>汇总（Summary）</h4><p>类似于直方图，汇总也对观察结果进行采样。除了可以统计采样值总和和总数，它还能够按分位数 统计。有以下几种方式来产生汇总（假设度量指标为 \<basename>）：</basename></p><p>按分位数，也就是采样值小于该分位数的个数占总数的比例小于 φ，相当于 <basename>{quantile=”&lt;φ&gt;”}<br>采样值总和，相当于 <basename>_sum<br>采样值总数，相当于 <basename>_count</basename></basename></basename></p><h2 id="任务（Job）和实例（Instance）"><a href="#任务（Job）和实例（Instance）" class="headerlink" title="任务（Job）和实例（Instance）"></a>任务（Job）和实例（Instance）</h2><p>在 Prometheus 里，可以从中抓取采样值的端点称为实例，为了性能扩展而复制出来的多个这样的实例形成了一个任务。</p><p>例如下面的 api-server 任务有四个相同的实例：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">job: api-server<br>instance 1: 1.2.3.4:5670<br>instance 2: 1.2.3.4:5671<br>instance 3: 5.6.7.8:5670<br>instance 4: 5.6.7.8:5671<br></code></pre></td></tr></table></figure></p><p>Prometheus 抓取完采样值后，会自动给采样值添加下面的标签和值：</p><p>job:抓取所属任务。<br>instance: 抓取来源实例</p><p>另外每次抓取时，Prometheus 还会自动在以下时序里插入采样值：</p><p>up{job=”[job-name]”, instance=”instance-id”}：<br>采样值为 1 表示实例健康，否则为不健康</p><p>scrape_duration_seconds{job=”[job-name]”, instance=”[instance-id]”}：<br>采样值为本次抓取消耗时间</p><p>scrape_samples_post_metric_relabeling{job=”<job-name>“, instance=”<instance-id>“}：<br>采样值为重新 打标签后的采样值个数</instance-id></job-name></p><p>scrape_samples_scraped{job=”<job-name>“, instance=”<instance-id>“}：<br>采样值 为本次抓取到的采样值个数</instance-id></job-name></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 监控 </category>
          
          <category> Prometheus </category>
          
          <category> 概要 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
