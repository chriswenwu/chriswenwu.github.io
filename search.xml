<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Prometheus 查询语言</title>
      <link href="/2019/03/22/Prometheus/query/"/>
      <url>/2019/03/22/Prometheus/query/</url>
      
        <content type="html"><![CDATA[<h2 id="PromQL-语法"><a href="#PromQL-语法" class="headerlink" title="PromQL 语法"></a>PromQL 语法</h2><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>PromQL 表达式计算出来的值有以下几种类型：</p><h3 id="瞬时向量-Instant-vector"><a href="#瞬时向量-Instant-vector" class="headerlink" title="瞬时向量 (Instant vector):"></a>瞬时向量 (Instant vector):</h3><ul><li>一组时序，每个时序只有一个采样值</li><li>区间向量 (Range vector): 一组时序，每个时序包含一段时间内的多个采样值</li><li>标量数据 (Scalar): 一个浮点数</li><li>字符串 (String): 一个字符串，暂时未用<a id="more"></a><h3 id="时序选择器"><a href="#时序选择器" class="headerlink" title="时序选择器"></a>时序选择器</h3></li></ul><h3 id="瞬时向量选择器"><a href="#瞬时向量选择器" class="headerlink" title="瞬时向量选择器"></a>瞬时向量选择器</h3><p>瞬时向量选择器用来选择一组时序在某个采样点的采样值。<br>最简单的情况就是指定一个度量指标，选择出所有属于该度量指标的时序的当前采样值。比如下面的表达式：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total<br></code></pre></td></tr></table></figure><p> 可以通过在后面添加用大括号包围起来的一组标签键值对来对时序进行过滤。比如下面的表达式筛选出了 job  为 prometheus，并且 group 为 canary 的时序：</p> <figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total&#123;job=<span class="hljs-string">"prometheus"</span>, group=<span class="hljs-string">"canary"</span>&#125;<br></code></pre></td></tr></table></figure><p>匹配标签 值时可以是等于，也可以使用正则表达式。总共有下面几种匹配操作符：</p><ul><li>=：完全相等</li><li>!=: 不相等</li><li>=~: 正则表达式匹配</li><li>!~: 正则表达式不匹配<br>下面的表达式筛选出了 environment 为 staging 或 testing 或 development，并且 method 不是 GET 的时序：</li></ul><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total&#123;environment=~<span class="hljs-string">"staging|testing|development"</span>,method!=<span class="hljs-string">"GET"</span>&#125;<br></code></pre></td></tr></table></figure><p>度量指标名可以使用内部标签 <strong>name</strong> 来匹配，表达式 http_requests_total 也可以写成 {<strong>name</strong>=”http_requests_total”}。表达式 {<strong>name</strong>=~”job:.*”} </p><p>匹配所有度量指标名称以 job: 打头的时序。</p><h3 id="区间向量选择器"><a href="#区间向量选择器" class="headerlink" title="区间向量选择器"></a>区间向量选择器</h3><p>区间向量选择器类似于瞬时向量选择器，不同的是它选择的是过去一段时间的采样值。可以通过在瞬时向量选择器后面添加包含在 [] 里的时长来得到区间向量选择器。<br>比如下面的表达式选出了所有度量指标为 http_requests_total 且 job 为 prometheus 的时序在过去 5 分钟的采样值。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total&#123;job=<span class="hljs-string">"prometheus"</span>&#125;[5m]<br></code></pre></td></tr></table></figure><p>时长的单位可以是下面几种之一：</p><ul><li>s：seconds</li><li>m：minutes</li><li>h：hours</li><li>d：days</li><li>w：weeks</li><li>y：years</li></ul><h3 id="偏移修饰器"><a href="#偏移修饰器" class="headerlink" title="偏移修饰器"></a>偏移修饰器</h3><p>前面介绍的选择器默认都是以当前时间为基准时间，偏移修饰器用来调整基准时间，使其往前偏移一段时间。<br>偏移修饰器紧跟在选择器后面，使用 offset 来指定要偏移的量。</p><p>比如下面的表达式选择度量名称为 http_requests_total 的所有时序在 5 分钟前的采样值。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total offset 5m<br></code></pre></td></tr></table></figure><p>下面的表达式选择 http_requests_total 度量指标在 1 周前的这个时间点过去 5 分钟的采样值。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_requests_total[5m] offset 1w<br></code></pre></td></tr></table></figure><h2 id="PromQL-操作符"><a href="#PromQL-操作符" class="headerlink" title="PromQL 操作符"></a>PromQL 操作符</h2><h3 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符"></a>二元操作符</h3><p>PromQL 的二元操作符支持基本的逻辑和算术运算，包含算术类、比较类和逻辑类 三大类。</p><h3 id="算术类二元操作符"><a href="#算术类二元操作符" class="headerlink" title="算术类二元操作符"></a>算术类二元操作符</h3><p>算术类二元操作符有以下几种：</p><ul><li>+：加</li><li>-：减</li><li>*：乘</li><li>/：除</li><li>%：求余</li><li>^：乘方</li></ul><p>算术类二元操作符可以 使用在标量与标量、向量与标量，以及向量与向量之间。</p><p>二元操作符上下文里的向量特指瞬时向量，不包括区间向量。</p><p>标量与标量之间，结果很明显，跟通常的算术运算一致。<br>向量与标量之间，相当于把标量跟向量里的每一个标量进行运算，这些 计算结果组成了一个新的向量。</p><p>向量与向量之间，会稍微麻烦一些。<br> 运算的时候 首先会为左边向量里的每一个元素在右边向量里去寻找一个匹配元素（匹配规则后面会讲），然后 对这两个匹配元素执行计算，这样每对匹配元素的计算结果组成了一个新的向量。<br>如果没有找到匹配元素，则该元素丢弃。</p><h3 id="比较类二元操作符"><a href="#比较类二元操作符" class="headerlink" title="比较类二元操作符"></a>比较类二元操作符</h3><p>比较类二元操作符有以下几种：</p><ul><li>== (equal)</li><li>!= (not-equal)</li><li><blockquote><p>(greater-than)</p></blockquote></li><li>&lt; (less-than)</li><li><blockquote><p>= (greater-or-equal)</p></blockquote></li><li>&lt;= (less-or-equal)</li></ul><p>比较类二元操作符同样可以 使用在标量与标量、向量与标量，以及向量与向量之间。<br>默认执行的是过滤，也就是保留值。可以通过在运算符后面跟 bool 修饰符来使得返回值 0 和 1，而不是过滤。</p><p>标量与标量之间，必须跟 bool 修饰符，因此结果只可能是 0（false） 或 1（true）。<br>向量与标量之间，相当于把向量里的每一个标量跟标量进行比较，结果 为真则保留，否则丢弃。<br>如果后面跟了 bool 修饰符，则结果分别为 1 和 0。</p><p>向量与向量之间，运算过程类似于算术类操作符，只不过 如果比较结果 为真则保留左边的值（包括度量指标和标签这些属性），否则丢弃， 没找到匹配也是丢弃。<br>如果后面跟了 bool 修饰符，则保留和丢弃时结果相应为 1 和 0。</p><h3 id="逻辑类二元操作符"><a href="#逻辑类二元操作符" class="headerlink" title="逻辑类二元操作符"></a>逻辑类二元操作符</h3><p>逻辑操作符仅用于 向量与向量之间。</p><ul><li>and：交集</li><li>or：合集</li><li>unless：补集</li></ul><p>具体运算规则如下：<br>vector1 and vector2 的结果<br>由在 vector2 里有匹配（标签键值对组合相同）元素的 vector1 里的元素组成。</p><p>vector1 or vector2 的结果<br>由所有 vector1 里的元素加上在 vector1 里没有匹配（标签键值对组合相同）元素的  vector2 里的元素组成。</p><p>vector1 unless vector2 的结果<br>由在 vector2 里没有匹配（标签键值对组合相同）元素的 vector1 里的元素组成。</p><h3 id="二元操作符优先级"><a href="#二元操作符优先级" class="headerlink" title="二元操作符优先级"></a>二元操作符优先级</h3><p>PromQL 的各类二元操作符运算优先级如下：</p><ul><li>^</li><li>*, /, %</li><li>+, -</li><li>==, !=, &lt;=, &lt;, &gt;=, &gt;</li><li>and, unless</li><li>or</li></ul><h3 id="向量匹配"><a href="#向量匹配" class="headerlink" title="向量匹配"></a>向量匹配</h3><p>前面算术类和比较类操作符都需要在向量之间进行匹配。 共有两种匹配类型，one-to-one 和 many-to-one / one-to-many。</p><h3 id="One-to-one-向量匹配"><a href="#One-to-one-向量匹配" class="headerlink" title="One-to-one 向量匹配"></a>One-to-one 向量匹配</h3><p>这种匹配模式下，两边向量里的元素如果其标签键值对组合相同则为匹配，并且 只会有一个匹配 元素。可以使用 ignoring 关键词来忽略不参与匹配的标签，或者使用 on 关键词来指定要参与匹配的标签。语法如下：</p><p><vector expr> <bin-op> ignoring(<label list>) <vector expr></vector></label></bin-op></vector></p><p><vector expr> <bin-op> on(<label list>) <vector expr></vector></label></bin-op></vector></p><p>比如对于下面的输入：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">method_code:http_errors:rate5m&#123;method=<span class="hljs-string">"get"</span>, code=<span class="hljs-string">"500"</span>&#125;  24<br>method_code:http_errors:rate5m&#123;method=<span class="hljs-string">"get"</span>, code=<span class="hljs-string">"404"</span>&#125;  30<br>method_code:http_errors:rate5m&#123;method=<span class="hljs-string">"put"</span>, code=<span class="hljs-string">"501"</span>&#125;  3<br>method_code:http_errors:rate5m&#123;method=<span class="hljs-string">"post"</span>, code=<span class="hljs-string">"500"</span>&#125; 6<br>method_code:http_errors:rate5m&#123;method=<span class="hljs-string">"post"</span>, code=<span class="hljs-string">"404"</span>&#125; 21<br><br>method:http_requests:rate5m&#123;method=<span class="hljs-string">"get"</span>&#125;  600<br>method:http_requests:rate5m&#123;method=<span class="hljs-string">"del"</span>&#125;  34<br>method:http_requests:rate5m&#123;method=<span class="hljs-string">"post"</span>&#125; 120<br></code></pre></td></tr></table></figure><p>执行下面的查询：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">method_code:http_errors:rate5m&#123;code=<span class="hljs-string">"500"</span>&#125; / ignoring(code) method:http_requests:rate5m<br></code></pre></td></tr></table></figure><p>得到的结果为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;method=<span class="hljs-string">"get"</span>&#125;  0.04            //  24 / 600<br>&#123;method=<span class="hljs-string">"post"</span>&#125; 0.05            //   6 / 120<br></code></pre></td></tr></table></figure><p>也就是每一种 method 里 code 为 500 的请求数占总数的百分比。由于 method 为 put 和 del 的没有匹配元素所以没有出现在结果里。</p><p>Many-to- one / one-to-many 向量匹配<br>这种匹配模式下，某一边会有多个元素跟另一边的元素匹配。这时就需要使用 group_left 或 group_right 组修饰符来指明哪边匹配元素较多，左边多则用 group_left，右边多则用 group_right。其语法如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;<br>&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;<br>&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;<br>&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;<br></code></pre></td></tr></table></figure><p>组修饰符只适用于算术类和比较类操作符。</p><p>对于前面的输入，执行下面的查询：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m<br></code></pre></td></tr></table></figure><p>将得到下面的结果：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;method=<span class="hljs-string">"get"</span>, code=<span class="hljs-string">"500"</span>&#125;  0.04            //  24 / 600<br>&#123;method=<span class="hljs-string">"get"</span>, code=<span class="hljs-string">"404"</span>&#125;  0.05            //  30 / 600<br>&#123;method=<span class="hljs-string">"post"</span>, code=<span class="hljs-string">"500"</span>&#125; 0.05            //   6 / 120<br>&#123;method=<span class="hljs-string">"post"</span>, code=<span class="hljs-string">"404"</span>&#125; 0.175           //  21 / 120<br></code></pre></td></tr></table></figure><p>也就是每种 method 的每种 code  错误次数占每种 method 请求数的比例。这里匹配的时候 ignoring 了 code，才使得两边可以形成 Many-to- one 形式的匹配。 由于左边多，所以需要使用 group_left 来指明。</p><p>Many-to- one / one-to-many 过于高级和复杂，要尽量避免使用。很多时候通过 ignoring 就可以解决问题。</p><h3 id="聚合操作符"><a href="#聚合操作符" class="headerlink" title="聚合操作符"></a>聚合操作符</h3><p>PromQL 的聚合操作符用来将向量里的元素聚合得 更少。总共有下面这些聚合操作符：</p><ul><li>sum：求和</li><li>min：最小值</li><li>max：最大值</li><li>avg：平均值</li><li>stddev：标准差</li><li>stdvar：方差</li><li>count： 元素个数</li><li>count_values：等于某值的元素个数</li><li>bottomk：最小的 k 个元素</li><li>topk：最大的 k 个元素</li><li>quantile：分位数</li></ul><p>聚合操作符语法如下：</p><p><aggr-op>([parameter,] <vector expression>) [without|by (<label list>)]<br>其中 without 用来指定不需要保留的标签（也就是这些标签的多个值会被聚合），而 by 正好相反，用来指定需要保留的标签（也就是按这些标签来聚合）。</label></vector></aggr-op></p><p>下面来看几个示例：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sum(http_requests_total) without (instance)<br></code></pre></td></tr></table></figure><p>http_requests_total 度量指标带有 application、instance  和 group 三个标签。上面的表达式会得到每个 application 的 每个 group 在所有 instance 上的请求总数。 效果等同于下面的表达式：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sum(http_requests_total) by (application, group)<br></code></pre></td></tr></table></figure><p>下面的表达式可以得到所有 application 的所有 group 的所有 instance 的请求总数。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sum(http_requests_total)<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Prometheus 内置了一些函数来辅助计算，下面介绍一些典型的，完整的列表请参考 官方文档。</p><ul><li>abs()：绝对值</li><li>sqrt()：平方根</li><li>exp()：指数计算</li><li>ln()：自然对数</li><li>ceil()：向上取整</li><li>floor()：向下 取整</li><li>round()：四舍五入取整</li><li>delta()：计算区间向量里每一个时序第一个和最后一个的差值</li><li>sort()：排序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 监控 </category>
          
          <category> Prometheus </category>
          
          <category> PromQL查询 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>健康检查</title>
      <link href="/2019/03/22/Docker/1.7%20Docker%20%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
      <url>/2019/03/22/Docker/1.7%20Docker%20%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-健康检查"><a href="#Docker-健康检查" class="headerlink" title="Docker 健康检查"></a>Docker 健康检查</h1><p>我们运行容器时，查看容器状态时，只显示容器是否正在运行。</p><p>如果出现这种情况：容器内的进程仍在运行，但是陷入了死循环出现假死状态，不能响应新的请求。Docker 是没有办法去判断这个容器内的服务是不可用的。</p><p>我们来模拟这种情况：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -d -p 80:80 --name nginx nginx:1.14.2<br>9a340f69249f387475bd22c08dbb96f4cae7712dab59f9af007a78589a2b0d01<br><br>$ docker container ls<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES<br>9a340f69249f        nginx:1.14.2        <span class="hljs-string">"nginx -g 'daemon of…"</span>   3 minutes ago       Up 3 minutes        0.0.0.0:80-&gt;80/tcp   nginx<br><br>$ curl -I http://127.0.0.1<br>HTTP/1.1 200 OK<br>Server: nginx/1.14.2<br>Date: Thu, 21 Feb 2019 18:16:21 GMT<br>Content-Type: text/html<br>Content-Length: 612<br>Last-Modified: Tue, 04 Dec 2018 14:44:49 GMT<br>Connection: keep-alive<br>ETag: <span class="hljs-string">"5c0692e1-264"</span><br>Accept-Ranges: bytes<br></code></pre></td></tr></table></figure><p>我们只能看到状态是 <code>UP</code> 状态，并且 Nginx 主页可以访问。</p><p>我们暂停进程：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -ef | grep -v grep | grep nginx<br>root     28760 28741  0 02:09 ?        00:00:00 nginx: master process nginx -g daemon off;<br>101      28798 28760  0 02:09 ?        00:00:00 nginx: worker process<br><br>$ <span class="hljs-built_in">kill</span> -s SIGSTOP 28760 28798<br><br>$ docker container ls<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES<br>9a340f69249f        nginx:1.14.2        <span class="hljs-string">"nginx -g 'daemon of…"</span>   9 minutes ago       Up 9 minutes        0.0.0.0:80-&gt;80/tcp   nginx<br><br>$ curl -I http://127.0.0.1<br></code></pre></td></tr></table></figure><blockquote><p>注：如果想恢复暂停的容器，发送 SIGCONT 信号： <code>kill -s SIGCONT &lt;进程 ID&gt;</code></p></blockquote><p>此时我们看到的状态依然是 <code>UP</code> 状态，看不出任何问题，但是 Nginx 主页已经无法访问。</p><p>所以我们需要利用健康检查机制来检测服务的可用性，防止类似于以上进程还在但服务无法访问的情况。</p><h2 id="容器添加健康检查"><a href="#容器添加健康检查" class="headerlink" title="容器添加健康检查"></a>容器添加健康检查</h2><p>Docker 提供了原生的健康检查实现，对应的参数为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">--health-cmd  <span class="hljs-comment"># 执行一个健康检查命令</span><br>--health-interval  <span class="hljs-comment"># 配合 --health-cmd 参数，设置健康检查的执行的间隔时间（单位：ms、s 、m、h）</span><br>--health-retries  <span class="hljs-comment"># 配合 --health-cmd 参数，设置健康检查命令失败重试的次数</span><br>--health-timeout  <span class="hljs-comment"># 配合 --health-cmd 参数，设置健康检查命令超时时间（单位：ms、s 、m、h）</span><br></code></pre></td></tr></table></figure><p>由于 Nginx 官方容器内没有 <code>curl</code> 命令，所以我们还需要制作一个带 <code>curl</code> 命令的 Nginx 容器。</p><p>Dockerfile 如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM nginx:1.14.2<br><br>RUN apt-get update -y &amp;&amp; apt-get install -y curl<br></code></pre></td></tr></table></figure><p>在 Dockerfile 同级目录下构建镜像：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tree<br>.<br>└── Dockerfile<br><br>0 directories, 1 file<br><br>$ docker image build -t nginx:1.14.2 .<br>...<br></code></pre></td></tr></table></figure><p>现在我们来执行一个带有健康检查机制的容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d \<br>    -p 80:80 \<br>    --health-cmd <span class="hljs-string">"curl --silent --fail --connect-timeout 3 http://localhost || exit 1"</span> \<br>    --health-interval 5s \<br>    --health-retries 5 \<br>    --health-timeout 2s \<br>    nginx:1.14.2<br>09118d61118af403dae9b33cf1efbaac36bd3162052eba3aa4c4b344efb61e1b<br></code></pre></td></tr></table></figure><p>此时我们在来看容器的运行状态：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker container ls<br>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                        PORTS                NAMES<br>09118d61118a        nginx:1.14.2        <span class="hljs-string">"nginx -g 'daemon of…"</span>   About a minute ago   Up About a minute (healthy)   0.0.0.0:80-&gt;80/tcp   nginx<br></code></pre></td></tr></table></figure><p>会发现查看容器的状态多了一种状态：<code>healthy</code>，说明这个容器是健康的。</p><p>我们使用 <code>docker container inspect</code> 命令来获取健康检查的记录：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker container inspect --format=<span class="hljs-string">'&#123;&#123;json .State.Health&#125;&#125;'</span> nginx | jq<br>&#123;<br>  <span class="hljs-string">"Status"</span>: <span class="hljs-string">"healthy"</span>,<br>  <span class="hljs-string">"FailingStreak"</span>: 0,<br>  <span class="hljs-string">"Log"</span>: [<br>    &#123;<br>      <span class="hljs-string">"Start"</span>: <span class="hljs-string">"2019-02-22T02:37:59.86587781+08:00"</span>,<br>      <span class="hljs-string">"End"</span>: <span class="hljs-string">"2019-02-22T02:38:00.02983152+08:00"</span>,<br>      <span class="hljs-string">"ExitCode"</span>: 0,<br>      <span class="hljs-string">"Output"</span>: <span class="hljs-string">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body &#123;\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n"</span><br>    &#125;<br>    ...<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来暂停进程：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -ef | grep -v grep | grep nginx<br>root     10198 10179  0 03:01 ?        00:00:00 nginx: master process nginx -g daemon off;<br>101      10233 10198  0 03:01 ?        00:00:00 nginx: worker process<br><br>$ <span class="hljs-built_in">kill</span> -s SIGSTOP 10198 10233<br><br>$ docker container ls<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS                NAMES<br>30f2c0ae85df        nginx:1.14.2        <span class="hljs-string">"nginx -g 'daemon of…"</span>   8 minutes ago       Up 8 minutes (unhealthy)   0.0.0.0:80-&gt;80/tcp   nginx<br><br>$ docker container inspect --format=<span class="hljs-string">'&#123;&#123;json .State.Health&#125;&#125;'</span> nginx | jq<br>&#123;<br>  <span class="hljs-string">"Status"</span>: <span class="hljs-string">"unhealthy"</span>,<br>  <span class="hljs-string">"FailingStreak"</span>: 6,<br>  <span class="hljs-string">"Log"</span>: [<br>    &#123;<br>      <span class="hljs-string">"Start"</span>: <span class="hljs-string">"2019-02-22T03:10:15.499220798+08:00"</span>,<br>      <span class="hljs-string">"End"</span>: <span class="hljs-string">"2019-02-22T03:10:17.499541229+08:00"</span>,<br>      <span class="hljs-string">"ExitCode"</span>: -1,<br>      <span class="hljs-string">"Output"</span>: <span class="hljs-string">"Health check exceeded timeout (2s)"</span><br>    &#125;<br>    ...<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就可以准确的知道容器内的服务是否可用。在进行监控或者自动化时就可以根据容器的健康检查状态返回的退出码（ExitCode）来进行判断了。</p><p>我们指定的健康检查命令为 <code>curl --silent --fail --connect-timeout 3 http://localhost || exit 1</code>，这条命令表示如果执行成功，则返回的值为 0，如果执行失败，则返回值为 1。</p><p><strong>指定健康检查的命令的返回值决定了容器的状态</strong>，可能的值为：</p><ul><li><p>0：healthy - 容器健康，可以使用；</p></li><li><p>1：unhealthy - 容器不健康，需要诊断；</p></li><li><p>2：reserved - 保留，不要使用这个返回值。</p></li></ul><h2 id="添加健康检查专用返回文本"><a href="#添加健康检查专用返回文本" class="headerlink" title="添加健康检查专用返回文本"></a>添加健康检查专用返回文本</h2><p>直接访问主页来执行健康检查有些不合适，我们还可以添加一个健康检查的配置：</p><p>在 Nginx 配置文件中添加一条健康检查的匹配规则：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat /data/nginx/conf.d/default.conf | awk <span class="hljs-string">'! /^$/ &amp;&amp; ! /^[ ]?.*#/ &#123; print &#125;'</span><br>server &#123;<br>    listen       80;<br>    server_name  localhost;<br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br>    location /health &#123;<br>        add_header Content-Type <span class="hljs-string">"text/plain;charset=utf-8"</span>;<br>        <span class="hljs-built_in">return</span> 200 <span class="hljs-string">"ok"</span>;<br>    &#125;<br>    error_page   500 502 503 504  /50x.html;<br>    location = /50x.html &#123;<br>        root   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后运行挂载配置目录来运行 Nginx 容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d \<br>    --name nginx \<br>    -p 80:80 \<br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,src=/data/nginx/conf.d/,dst=/etc/nginx/conf.d \<br>    --health-cmd <span class="hljs-string">"curl --silent --fail --connect-timeout 3 http://localhost/health || exit 1"</span> \<br>    --health-interval 5s \<br>    --health-timeout 2s \<br>    nginx:1.14.2<br>57f9378df04830a9e7081aff8efc13109b200799b11d2cd2d924a8ae276e8fc5<br></code></pre></td></tr></table></figure><p>此时我们在获取健康检查记录就精简多了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container inspect --format=<span class="hljs-string">'&#123;&#123;json .State.Health&#125;&#125;'</span> nginx | jq<br>&#123;<br>  <span class="hljs-string">"Status"</span>: <span class="hljs-string">"healthy"</span>,<br>  <span class="hljs-string">"FailingStreak"</span>: 0,<br>  <span class="hljs-string">"Log"</span>: [<br>    &#123;<br>      <span class="hljs-string">"Start"</span>: <span class="hljs-string">"2019-02-22T03:01:52.41008393+08:00"</span>,<br>      <span class="hljs-string">"End"</span>: <span class="hljs-string">"2019-02-22T03:01:52.561938938+08:00"</span>,<br>      <span class="hljs-string">"ExitCode"</span>: 0,<br>      <span class="hljs-string">"Output"</span>: <span class="hljs-string">"ok"</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的，在 Java 程序中，也可以添加一个专用的接口提供给健康检查机制使用：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">@RestController<br>@RequestMapping(path = <span class="hljs-string">"/"</span>)<br>public class Healthz &#123;<br>    @GetMapping(path = <span class="hljs-string">"/health"</span>,produces = MediaType.TEXT_PLAIN_VALUE)<br>    public String <span class="hljs-function"><span class="hljs-title">healthz</span></span>()&#123;<br>        <span class="hljs-built_in">return</span> <span class="hljs-string">"ok"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>只是看容器是否正在运行时没办法保证服务是可用的，我们需要使用健康检查来确保服务是可用的。</p></li><li><p>我们最好准备一个专用的返回文本或页面来提供给健康检查机制使用。</p></li><li><p>我们可以根据健康检查的返回状态码来更准确的监控容器是否可用，Kubernetes 也会根据健康检查返回的状态来判断容器是否可用执行对应的自动化操作。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com/engine/reference/run/#healthcheck" target="_blank" rel="noopener">Docker HEALTHCHECK</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
          <category> Dokcer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 数据卷的使用与挂载主机目录</title>
      <link href="/2019/03/22/Docker/1.3%20Docker%20%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95/"/>
      <url>/2019/03/22/Docker/1.3%20Docker%20%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-3-Docker-数据卷的使用与挂载主机目录"><a href="#1-3-Docker-数据卷的使用与挂载主机目录" class="headerlink" title="1.3 Docker 数据卷的使用与挂载主机目录"></a>1.3 Docker 数据卷的使用与挂载主机目录</h1><p>容器运行时，会在容器内创建一层临时的可读写层。在容器内创建的所有文件都存储在这个临时的可读写层，当容器停止或者删除，这个可读写层会被清空。这意味着：<strong>当容器停止或删除后，在容器内变更的数据也会丢失</strong>。</p><p>因此，我们需要把持久化的数据保存在宿主机上，保证容器停止或删除之后数据依然存在。</p><p>Docker 容器中管理数据主要有两种方式：</p><ul><li><p>数据卷（Data Volumes）</p></li><li><p>挂载主机目录（Bind Mounts）</p></li></ul><p>我们用一张官方的图来描述这两种方式：</p><p><img src="/images/Docker数据卷类型.png" alt="Docker 数据卷类型"></p><ul><li><p>数据卷：存储在由 Docker 管理的主机文件系统中，Linux 系统上默认为 /var/lib/docker/volumes/ 目录下。</p></li><li><p>挂载主机目录：可以存储在主机文件系统上的任何位置。</p></li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS（Docker 使用的联合文件系统），可以提供很多特性：</p><ul><li><p>数据卷可以在容器之间共享和重用；</p></li><li><p>数据卷同时适用于 Linux 和 Windows 容器；</p></li><li><p>数据卷更易与备份或迁移；</p></li><li><p>对数据卷的更新，不会影响镜像；</p></li><li><p>即使容器被删除，数据卷也会一直存在，除非手动删除数据卷。</p></li></ul><p>首先我们来需要来创建一个 Docker 数据卷，Docker 提供了 <code>docker volume create</code> 命令来创建数据卷：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume create nginx<br>nginx<br></code></pre></td></tr></table></figure><p>创建完成之后，我们使用 <code>docker volume ls</code> 来查看所有的数据卷：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume ls<br>DRIVER              VOLUME NAME<br><span class="hljs-built_in">local</span>               nginx<br></code></pre></td></tr></table></figure><p>我们还可以使用 <code>docker volume inspect</code> 来查看指定数据卷的信息：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume inspect nginx<br>[<br>    &#123;<br>        <span class="hljs-string">"CreatedAt"</span>: <span class="hljs-string">"2019-02-14T14:40:40+08:00"</span>,<br>        <span class="hljs-string">"Driver"</span>: <span class="hljs-string">"local"</span>,<br>        <span class="hljs-string">"Labels"</span>: &#123;&#125;,<br>        <span class="hljs-string">"Mountpoint"</span>: <span class="hljs-string">"/var/lib/docker/volumes/nginx/_data"</span>,<br>        <span class="hljs-string">"Name"</span>: <span class="hljs-string">"nginx"</span>,<br>        <span class="hljs-string">"Options"</span>: &#123;&#125;,<br>        <span class="hljs-string">"Scope"</span>: <span class="hljs-string">"local"</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>有了数据卷，我们使用 <code>docker container run</code> 启动容器时，就可以使用 <code>-v</code> 或 <code>--mount</code> 参数来将数据卷挂载到容器里。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -d -p 80:80 --name nginx \<br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">source</span>=nginx,target=/usr/share/nginx/html \<br>    nginx:1.14.2<br>f690bf43c31de5aca3dd8ca036571d3402098fc76c89ced7320ced822bc824c7<br></code></pre></td></tr></table></figure><p>我们可以使用 <code>docker container inspect</code> 命令来获取容器的挂载信息：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container inspect  -f <span class="hljs-string">"&#123;&#123; .Mounts | json &#125;&#125;"</span> nginx | jq<br>[<br>  &#123;<br>    <span class="hljs-string">"Type"</span>: <span class="hljs-string">"volume"</span>,<br>    <span class="hljs-string">"Name"</span>: <span class="hljs-string">"nginx"</span>,<br>    <span class="hljs-string">"Source"</span>: <span class="hljs-string">"/var/lib/docker/volumes/nginx/_data"</span>,<br>    <span class="hljs-string">"Destination"</span>: <span class="hljs-string">"/usr/share/nginx/html"</span>,<br>    <span class="hljs-string">"Driver"</span>: <span class="hljs-string">"local"</span>,<br>    <span class="hljs-string">"Mode"</span>: <span class="hljs-string">"z"</span>,<br>    <span class="hljs-string">"RW"</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">"Propagation"</span>: <span class="hljs-string">""</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>这时我们直接修改宿主机上 /var/lib/docker/volumes/nginx/_data 目录下的文件即可修改主页：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /var/lib/docker/volumes/nginx/_data/<br><br>$ ls<br>50x.html  index.html<br><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'Wherever there are people, there is Jianghu'</span> &gt; index.html<br></code></pre></td></tr></table></figure><p>此时访问 <a href="http://10.10.113.16" target="_blank" rel="noopener">http://10.10.113.16</a> ，就可以看到修改后的主页了。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://10.10.113.16<br>Wherever there are people, there is Jianghu<br></code></pre></td></tr></table></figure><p>当我们删除容器时，如果不需要保存数据，记得使用 <code>docker volume rm</code> 命令删除数据卷以释放磁盘资源。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container rm -f nginx<br>nginx<br><br>$ docker volume rm nginx<br>nginx<br></code></pre></td></tr></table></figure><p>我们还可以使用 <code>docker volume prune</code> 来清理无主的数据卷，如果不确定数据卷是否需要删除，慎用这个命令。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker volume prune<br>WARNING! This will remove all <span class="hljs-built_in">local</span> volumes not used by at least one container.<br>Are you sure you want to <span class="hljs-built_in">continue</span>? [y/N] y<br>Total reclaimed space: 0B<br></code></pre></td></tr></table></figure><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><p>有时候，我们需要将主机目录挂载至容器内。将主机目录作为一个数据卷：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir -p /data/nginx/<br><br>$ docker container run -d -p 80:80 --name nginx --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/data/nginx,target=/usr/share/nginx/html nginx:1.14.2<br>0c1b2623dee24f5e6866df2aa480055deb5c9da8927ff86aeea3cf838f7c2f65<br></code></pre></td></tr></table></figure><p>我们在来查看容器内的挂载信息：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container inspect  -f <span class="hljs-string">"&#123;&#123; .Mounts | json &#125;&#125;"</span> nginx | jq<br>[<br>  &#123;<br>    <span class="hljs-string">"Type"</span>: <span class="hljs-string">"bind"</span>,<br>    <span class="hljs-string">"Source"</span>: <span class="hljs-string">"/data/nginx"</span>,<br>    <span class="hljs-string">"Destination"</span>: <span class="hljs-string">"/usr/share/nginx/html"</span>,<br>    <span class="hljs-string">"Mode"</span>: <span class="hljs-string">""</span>,<br>    <span class="hljs-string">"RW"</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">"Propagation"</span>: <span class="hljs-string">"rprivate"</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>此时，我们就可以进入主机目录 /data/nginx/ 添加主页了。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /data/nginx/<br><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-built_in">test</span> &gt; index.html<br><br>$ curl http://10.10.113.16<br><span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h2 id="v-或-–mount-的选择"><a href="#v-或-–mount-的选择" class="headerlink" title="-v 或 –mount 的选择"></a>-v 或 –mount 的选择</h2><p>我一直都习惯于用 <code>-v</code> 来挂载数据卷或者挂载主机宿主目录，但 <code>--mount</code> 参数更加明确。 </p><p>对于刚接触 Docker 的用户来说，应该尝试使用 <code>--mount</code> 而不是 <code>-v</code> 参数。 对于已经对 <code>-v</code> 或者 <code>--volume</code> 已经很数据的用户，还是推荐使用 <code>--mount</code> 参数。</p><p><strong>-v 或 –volume</strong>：由 3 个字段组成，用冒号（:）分隔。字段必须按照正确的顺序排列：</p><ul><li><p>第一个字段：对于命名卷，第一个字段是卷的名称。对于匿名卷，省略第一个字段。</p></li><li><p>第二个字段：是文件或者目录在容器中挂载的路径。</p></li><li><p>第三个字段：这个字段是可选的，是用逗号（,）分隔的选项列表，例如 <code>ro</code>。</p></li></ul><p><strong>–mount</strong>：由多个键值对组成，以逗号（,）分隔。</p><ul><li><p>type 键：值可以是 <code>bind</code>、<code>volume</code>或<code>tmpfs</code>，不填写此字段默认为 <code>volume</code>。</p></li><li><p>source 或 src 键：对于命名卷，值为卷的名称；对于匿名卷，此键值对省略。</p></li><li><p>destination、dst 或 target 键：值为容器中挂载的路径。</p></li><li><p>readonly 键：该键如果存在，表示以只读方式挂载至容器内。</p></li><li><p>volume-opt 键：该键可以多次指定，它采用由选项名称及其值组成的键值对做为值。</p></li></ul><p>并且如果需要指定卷驱动程序选项，则必须使用 <code>--mount</code> 选项。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们使用了两种方式来持久化容器内的数据：</p><ol><li><p>通过创建 Docker 数据卷来持久化数据，Docker 数据卷操作的所有命令如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume --<span class="hljs-built_in">help</span><br><br>Usage:  docker volume COMMAND<br><br>Manage volumes<br><br>Commands:<br>  create      Create a volume<br>  inspect     Display detailed information on one or more volumes<br>  ls          List volumes<br>  prune       Remove all unused <span class="hljs-built_in">local</span> volumes<br>  rm          Remove one or more volumes<br><br>Run <span class="hljs-string">'docker volume COMMAND --help'</span> <span class="hljs-keyword">for</span> more information on a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure></li><li><p>通过挂载主机目录来持久化容器内的数据。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">Docker Use volumes</a></p></li><li><p><a href="https://docs.docker.com/storage/bind-mounts/" target="_blank" rel="noopener">Docker Use bind mounts</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
          <category> Dokcer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 网络配置</title>
      <link href="/2019/03/22/Docker/1.4%20Docker%20%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/22/Docker/1.4%20Docker%20%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-4-Docker-网络配置"><a href="#1-4-Docker-网络配置" class="headerlink" title="1.4 Docker 网络配置"></a>1.4 Docker 网络配置</h1><p>Docker 有 4 种网络模式：</p><ul><li><p>Bridge 模式</p></li><li><p>Host 模式</p></li><li><p>Container 模式</p></li><li><p>None 模式</p></li></ul><p>我们主要说明 Bridge 模式和 Host 模式。Container 与 None 模式很少会使用，只做一些简单介绍。</p><h2 id="Bridge-模式"><a href="#Bridge-模式" class="headerlink" title="Bridge 模式"></a>Bridge 模式</h2><p>当 Docker 进程启动时，会在主机上创建一个名为 docker0 的虚拟网桥：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># CentOS 7 中使用 ifconfig，需要下载 net-tools 包</span><br><span class="hljs-comment"># 下载命令为 yum install -y net-tools</span><br>$ ifconfig<br>docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255<br>        inet6 fe80::42:23ff:fe4b:b4f0  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        ether 02:42:23:4b:b4:f0  txqueuelen 0  (Ethernet)<br>        RX packets 167  bytes 14591 (14.2 KiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 201  bytes 22329 (21.8 KiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br>...<br></code></pre></td></tr></table></figure><p>此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上所有容器就通过交换机连在了一个二层网络中：</p><ol><li><p>从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的<strong>默认网关</strong>；</p></li><li><p>在主机上创建一对虚拟网卡 veth pair 设备，Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0（容器内的网卡）；</p></li><li><p>另一端放在主机中，以 veth 开头加上一串哈希字符串来命名，并将这个网络设备加入到 docker0 网桥中。</p></li></ol><p>我们来验证上述的说明：</p><p>首先我们先启动一个容器，Docker 启动容器时默认的网络模式即为 Bridge 模式：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -itd --name busybox busybox /bin/sh<br>37d96cfa7d54d6d55f57591d0e0e288eb3494d37060ddbde3b84bb358731dc28<br></code></pre></td></tr></table></figure><p>我们查看主机网络中多了一个 veth pair 虚拟网卡：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ifconfig<br>...<br>vethe0b273b: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet6 fe80::cc1d:91ff:fe3d:2e42  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        ether ce:1d:91:3d:2e:42  txqueuelen 0  (Ethernet)<br>        RX packets 0  bytes 0 (0.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 8  bytes 656 (656.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br></code></pre></td></tr></table></figure><p>然后可以通过 brctl show 命令查看 docker0 网桥中管理的网络设备：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># CentOS 7 中使用 brctl，需要下载 bridge-utils 包</span><br><span class="hljs-comment"># 下载命令为 yum install -y bridge-utils</span><br>$ brctl show<br>bridge name bridge id       STP enabled interfaces<br>docker0     8000.0242234bb4f0   no      vethe0b273b<br></code></pre></td></tr></table></figure><p>接下来我们查看容器内的 eth0 网卡：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">exec</span> busybox ifconfig<br>eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  <br>          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:8 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:0 <br>          RX bytes:656 (656.0 B)  TX bytes:0 (0.0 B)<br>...<br></code></pre></td></tr></table></figure><p>最后，Docker 会为 docker0 网桥设备添加一条路由通过 iptables nat 表进行转发，这样主机和容器就能进行通信了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0<br><br>$ docker container <span class="hljs-built_in">exec</span> busybox route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0<br></code></pre></td></tr></table></figure><p>我们用一张图来描述 Bridge 模式：</p><p><img src="/images/DockerBridge模式.png" alt="Docker Bridge 模式"></p><p>在 Bridge 模式下，如果外部想要访问容器，在运行容器时需要通过 <code>-p &lt;port&gt;:&lt;port&gt;</code> 将容器端口映射至宿主机，比如之前运行过的 Nginx 容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d --name nginx -p 80:80 nginx:1.14.2<br></code></pre></td></tr></table></figure><h2 id="自定义-Docker-网桥设备"><a href="#自定义-Docker-网桥设备" class="headerlink" title="自定义 Docker 网桥设备"></a>自定义 Docker 网桥设备</h2><p>我们现在想让容器网络之间互联，如果之前有用过 Docker，应该知道 <code>--link</code> 参数来使容器网络互联。但随着 Docker 网络的发展，现在已经不推荐使用 <code>--link</code> 这种方式了，因为在网络环境很复杂的情况下，使用 <code>--link</code> 描述这种复杂的网络关系会显得很稚嫩。</p><p>现在官方给出的建议是将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p><p>我们先创建一个新的 Docker 桥接网络：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker network create -d bridge my-net<br>31dcb22d213582152740df83bf5b9a5d3d30426b5d336eef276ff7702c875690<br></code></pre></td></tr></table></figure><p><code>-d</code> 参数指定 Docker 网络类型，有两种网络类型：</p><ul><li><p>bridge：桥接网络，默认就是 bridge。</p></li><li><p>overlay：用于 Swarm mode，我们以后会讲到。</p></li></ul><p>运行两个容器并将这两个容器连接到自定义的 my-net 网络：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -itd --name busybox-1 --network my-net busybox /bin/sh<br>0423df78b4b5066511e13b83a2fd55ff7dc51e600c8a743fb7268bea9e06c803<br><br>$ docker container run -itd --name busybox-2 --network my-net busybox /bin/sh<br>4ccd47271daa621232b97306f908e190c1d3264725e05b398da96870f94bf799<br><br>$ docker container ls<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br>4ccd47271daa        busybox             <span class="hljs-string">"/bin/sh"</span>           2 minutes ago       Up 2 minutes                            busybox-2<br>0423df78b4b5        busybox             <span class="hljs-string">"/bin/sh"</span>           2 minutes ago       Up 2 minutes                            busybox-1<br></code></pre></td></tr></table></figure><p>我们在 busybox-1 与 busybox-2 容器内执行 Ping 命令来验证是否容器之间是互联的：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> busybox-1 ping -c 4 busybox-2<br>PING busybox-2 (172.18.0.3): 56 data bytes<br>64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.118 ms<br>64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.117 ms<br>64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.115 ms<br>64 bytes from 172.18.0.3: seq=3 ttl=64 time=0.143 ms<br><br>$ docker <span class="hljs-built_in">exec</span> busybox-2 ping -c 4 busybox-1<br>PING busybox-1 (172.18.0.2): 56 data bytes<br>64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.144 ms<br>64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.121 ms<br>64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.108 ms<br>64 bytes from 172.18.0.2: seq=3 ttl=64 time=0.112 ms<br></code></pre></td></tr></table></figure><p>此时我们查看主机上的网卡，发现多了一个我们自定义的网桥设备，并且加入自定义网桥设备的容器会按照顺序来为容器分配 IP 地址：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ifconfig<br>br-31dcb22d2135: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255<br>        inet6 fe80::42:ecff:fe4b:bb2f  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        ether 02:42:ec:4b:bb:2f  txqueuelen 0  (Ethernet)<br>        RX packets 130  bytes 12144 (11.8 KiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 147  bytes 13798 (13.4 KiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br></code></pre></td></tr></table></figure><p>所以自定义桥接网络（my-net）相比使用默认的桥接网络（docker0）有以下好处：</p><ul><li><p><strong>用户定义的桥接网络可在容器化应用程序之间提供更好的隔离和相互操作性</strong>。因为连接到同一个自定义网桥的容器会自动的将所有端口互相暴露，并且不会向外界暴露任何端口，更不会向其他网桥中的容器暴露端口。这使得在同一个自定义网桥中的容器中的应用程序可以轻松的相互通信，还可以与其他网络中的容器进行隔离。</p></li><li><p><strong>用户定义的桥接网络在容器之间提供自动的 DNS 解析</strong>。默认情况下，容器之间只能使用 IP 地址进行相互访问，使用默认网桥，IP 地址有可能发生变化。如果加入了自定义网桥，容器可以通过容器名或者别名相互解析。我们在上述的实验中也验证了这一点。</p></li></ul><h2 id="Host-模式"><a href="#Host-模式" class="headerlink" title="Host 模式"></a>Host 模式</h2><p>如果启动容器时使用的是 <code>host</code> 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。</p><p>Docker 不会为容器虚拟出独立的网卡、配置容器内的 IP 地址等，而是直接使用宿主机的 IP 地址和端口。但是容器的其他方面，比如文件系统、进程列表、主机名等还是和宿主机隔离的，仅仅是网络不再和宿主机隔离。</p><p>我们用一张图来描述 Host 模式：</p><p><img src="/images/DockerHost模式.png" alt="Docker Host 模式"></p><p>我们来演示一下容器使用 Host 网络模式：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d --network host --name nginx --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,src=/usr/sbin/ifconfig,dst=/usr/sbin/ifconfig nginx:1.14.2<br>88f9a6a878f8189ad325edc0787b922c085e3a4878556ebddbb19a8e03593dcb<br></code></pre></td></tr></table></figure><blockquote><p>为了在容器内能使用 <code>ifconfig</code> 命令，我把宿主机中的 <code>ifconfig</code> 程序挂载到容器内方便演示。</p></blockquote><p>我们在容器内执行 <code>ifconfig</code> 命令查看下容器内的网络：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> nginx ifconfig<br>...<br>docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500<br>        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255<br>        inet6 fe80::42:23ff:fe4b:b4f0  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        ether 02:42:23:4b:b4:f0  txqueuelen 0  (Ethernet)<br>        RX packets 167  bytes 14591 (14.2 KiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 201  bytes 22329 (21.8 KiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>ens192: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 10.10.113.16  netmask 255.255.255.0  broadcast 10.10.113.255<br>        inet6 fe80::250:56ff:fe9f:bf65  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        ether 00:50:56:9f:bf:65  txqueuelen 1000  (Ethernet)<br>        RX packets 281745  bytes 380258624 (362.6 MiB)<br>        RX errors 0  dropped 142  overruns 0  frame 0<br>        TX packets 248819  bytes 19673141 (18.7 MiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br>...<br></code></pre></td></tr></table></figure><p>会发现和宿主机使用 <code>ifconfig</code> 命令查看到的内容完全相同，因为使用了 Host 模式，容器内的网络和宿主机不再进行隔离，共用一个网络空间。</p><p>这时不需要使用 <code>-p</code> 参数添加端口映射，会直接在宿主机上监听 80 端口了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ netstat -anptl | grep 80<br>tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      25635/nginx: master<br></code></pre></td></tr></table></figure><p>使用 Host 模式需要注意端口是否冲突，以及是否暴露了不想暴露的端口号导致一些安全性的问题。</p><h2 id="Container-模式"><a href="#Container-模式" class="headerlink" title="Container 模式"></a>Container 模式</h2><p>Container 模式会指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，即共享一个网络空间，而不是和宿主机共享。</p><p>Docker 不会为新创建的容器创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP 地址等。同样，两个容器除了网络空间，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><p>我们用一张图来描述 Container 模式：</p><p><img src="/images/DockerContainer模式.png" alt="Docker Container 模式"></p><p>这个模式在某些情况下表现出色，Kubernetes 就是采用这种模式将 Pod 下的所有容器共用一个网络空间，后续讲 Kubernetes 时我们会讲到。</p><h2 id="None-模式"><a href="#None-模式" class="headerlink" title="None 模式"></a>None 模式</h2><p>使用 None 模式，Docker 容器拥有自己的 Network Namespace。但是 Docker 不会为容器进行任何网络配置。也就是说容器内没有网卡、IP、路由等信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>配置 Docker 网络模式最常用的就是使用网桥模式，然后通过 <code>-p</code> 参数把容器内的端口映射至宿主机。</p></li><li><p>如果我们想让一部分容器之间的网络共享，最好自定义一个桥接网络，然后把这些容器都加入到这个自定义桥接网络当中。</p></li><li><p>如果你不想对容器进行网络隔离，可以使用 Host 模式将服务直接暴露在宿主机当中。</p></li><li><p>Container 模式与 Host 模式类似，只是不是共享宿主机的网络空间，而是共享另一个容器的网络空间。</p></li><li><p>None 模式说白了就是关闭容器的网络连接。</p></li></ol><p>还有一些网络模式这里没有提到 比如说 overlay 模式用于 Docker Swarm，Macvlan 可以用来配置更加复杂的网络。现在用的很少，感兴趣的话可以在参考中的链接中参考下这两种网络模式，或者自己找些资料进行实验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://docs.docker.com/network/bridge/" target="_blank" rel="noopener">Docker Use bridge networks</a></p></li><li><p><a href="https://docs.docker.com/network/host/" target="_blank" rel="noopener">Docker Use host networking</a></p></li><li><p><a href="https://docs.docker.com/network/overlay/" target="_blank" rel="noopener">Docker Use overlay networks</a></p></li><li><p><a href="https://docs.docker.com/network/macvlan/" target="_blank" rel="noopener">Docker Use Macvlan networks</a></p></li><li><p><a href="https://cizixs.com/2017/02/14/network-virtualization-macvlan/" target="_blank" rel="noopener">linux 网络虚拟化： macvlan</a></p></li><li><p><a href="https://www.cnblogs.com/bigberg/p/8656963.html" target="_blank" rel="noopener">Docker Macvlan</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
          <category> Dokcer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 资源限制</title>
      <link href="/2019/03/22/Docker/1.5%20Docker%20%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/"/>
      <url>/2019/03/22/Docker/1.5%20Docker%20%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-5-Docker-资源限制"><a href="#1-5-Docker-资源限制" class="headerlink" title="1.5 Docker 资源限制"></a>1.5 Docker 资源限制</h1><p>使用 Docker 运行容器时，一台主机上可能运行多个容器，这些容器虽然相互隔离，但是底层却使用着相同的 CPU、内存和磁盘资源。如果不对容器使用的资源进行限制，那么容器之间会互相影响。可能导致各容器的资源分配不合理，甚至可能会因为某个容器占用资源过多导致主机资源耗尽，影响主机上所有的容器。</p><p>Docker 作为容器的管理者，自然提供了控制容器资源的功能，包括 CPU、内存和磁盘 IO。</p><p>我之前在介绍 Docker 时说过 Docker 是通过 Linux 内核的 CGroups 技术来做容器的资源限制。这里只介绍 Docker 如何来对容器进行资源限制，实现的细节可以参考第一章的链接，这里就不做介绍了。</p><h2 id="Stress-工具介绍"><a href="#Stress-工具介绍" class="headerlink" title="Stress 工具介绍"></a>Stress 工具介绍</h2><p>在介绍容器资源限制时需要用到压测工具进行测试，所以我们先介绍一个压力测试软件：Stress。</p><p>首先安装 Stress：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum install -y stress<br></code></pre></td></tr></table></figure><p>来看一下 Stress 命令帮助：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">stress --<span class="hljs-built_in">help</span><br><span class="hljs-string">'stress'</span> imposes certain types of compute stress on your system<br><br>Usage: stress [OPTION [ARG]] ...<br> -?, --<span class="hljs-built_in">help</span>         show this <span class="hljs-built_in">help</span> statement <span class="hljs-comment"># 显示帮助信息</span><br>     --version      show version statement <span class="hljs-comment"># 显示版本号</span><br> -v, --verbose      be verbose <span class="hljs-comment"># 详细模式</span><br> -q, --quiet        be quiet <span class="hljs-comment"># 静默模式，不显示运行信息</span><br> -n, --dry-run      show what would have been <span class="hljs-keyword">done</span> <span class="hljs-comment"># 显示已经完成的指令执行情况</span><br> -t, --timeout N    timeout after N seconds <span class="hljs-comment"># 指定运行 N 秒后停止</span><br>     --backoff N    <span class="hljs-built_in">wait</span> factor of N microseconds before work starts <span class="hljs-comment"># 等待 N 微妙后开始运行</span><br> -c, --cpu N        spawn N workers spinning on sqrt() <span class="hljs-comment"># 产生 N 个进程 每个进程都反复不停的执行 sqrt() 计算随机数的平方根</span><br> -i, --io N         spawn N workers spinning on sync() <span class="hljs-comment"># 产生 N 个进程 每个进程反复调用 sync()，sync() 用于将内存上的内容写到硬盘上</span><br> -m, --vm N         spawn N workers spinning on malloc()/free() <span class="hljs-comment"># 产生 N 个进程,每个进程不断调用内存分配 malloc() 和内存释放 free() 函数</span><br>     --vm-bytes B   malloc B bytes per vm worker (default is 256MB) <span class="hljs-comment"># 指定 malloc() 时内存的字节数 (默认 256MB)</span><br>     --vm-stride B  touch a byte every B bytes (default is 4096)<br>     --vm-hang N    sleep N secs before free (default none, 0 is inf) <span class="hljs-comment"># 表示 malloc 分配的内存 N 秒后再使用 free() 释放掉</span><br>     --vm-keep      redirty memory instead of freeing and reallocating <span class="hljs-comment"># 不释放内存资源</span><br> -d, --hdd N        spawn N workers spinning on write()/unlink() <span class="hljs-comment"># 产生 N 个进程，每个进程执行 write() 和 unlink () 函数</span><br>     --hdd-bytes B  write B bytes per hdd worker (default is 1GB) <span class="hljs-comment"># 指定写的字节数，默认是 1GB</span><br><br>Example: stress --cpu 8 --io 4 --vm 2 --vm-bytes 128M --timeout 10s<br><br>Note: Numbers may be suffixed with s,m,h,d,y (time) or B,K,M,G (size).<br></code></pre></td></tr></table></figure><p>来举一些例子：</p><p>我使用的主机 CPU 核心数为 4 核，我们产生 2 个 CPU 进程：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ stress --verbose -c 2<br>stress: info: [18148] dispatching hogs: 2 cpu, 0 io, 0 vm, 0 hdd<br>stress: dbug: [18148] using backoff sleep of 6000us<br>stress: dbug: [18148] --&gt; hogcpu worker 2 [18149] forked<br>stress: dbug: [18148] using backoff sleep of 3000us<br>stress: dbug: [18148] --&gt; hogcpu worker 1 [18150] forked<br></code></pre></td></tr></table></figure><p>我们在另一个终端上使用 <code>top</code> 命令查看结果：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ top<br>...<br>%Cpu(s): 50.0 us,  0.1 sy,  0.0 ni, 49.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>...<br>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                       <br>18149 root      20   0    7308    100      0 R 100.0  0.0   1:23.92 stress                                                                     <br>18150 root      20   0    7308    100      0 R 100.0  0.0   1:23.92 stress<br></code></pre></td></tr></table></figure><p>发现，CPU 已经用了一半，每个 Stress 产生的进程都用了一个核心。</p><p>我们再来产生 4 个 I/O 进程，I/O 进程会不断把内存中的内容复制到磁盘上，这将消耗内核态的 CPU 资源：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ stress --verbose -i 4<br>stress: info: [18262] dispatching hogs: 0 cpu, 4 io, 0 vm, 0 hdd<br>stress: dbug: [18262] using backoff sleep of 12000us<br>stress: dbug: [18262] --&gt; hogio worker 4 [18263] forked<br>stress: dbug: [18262] using backoff sleep of 9000us<br>stress: dbug: [18262] --&gt; hogio worker 3 [18264] forked<br>stress: dbug: [18262] using backoff sleep of 6000us<br>stress: dbug: [18262] --&gt; hogio worker 2 [18265] forked<br>stress: dbug: [18262] using backoff sleep of 3000us<br>stress: dbug: [18262] --&gt; hogio worker 1 [18266] forked<br><br>$ top<br>...<br>%Cpu(s):  0.3 us, 81.5 sy,  0.0 ni, 18.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>...<br>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                     <br>18265 root      20   0    7308    100      0 R  76.4  0.0   2:21.05 stress<br>18266 root      20   0    7308    100      0 R  76.4  0.0   2:20.90 stress<br>18263 root      20   0    7308    100      0 R  76.1  0.0   2:20.62 stress<br>18264 root      20   0    7308    100      0 R  76.1  0.0   2:20.97 stress<br></code></pre></td></tr></table></figure><p>可以发现 I/O 操作消耗的资源主要为内核态 CPU 资源。</p><p>接下来做内存的压力测试，我们产生 2 个 2G 的内存分配进程，并且不进行释放：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先看下这台服务器的内存</span><br>$ free -m<br>              total        used        free      shared  buff/cache   available<br>Mem:           7821         217        6997           8         606        7319<br>Swap:          8191           0        8191<br><br>$ stress --vm 2 --vm-bytes 2G --vm-keep<br>stress: info: [18312] dispatching hogs: 0 cpu, 0 io, 2 vm, 0 hdd<br><br><span class="hljs-comment"># 在另一个终端执行</span><br>$ free -m<br>              total        used        free      shared  buff/cache   available<br>Mem:           7821        4320        2894           8         606        3216<br>Swap:          8191           0        8191<br></code></pre></td></tr></table></figure><p>发现一共占用了 4GB 的内存资源。</p><p>最后做磁盘读写的测试，我们产生 1 个磁盘写的进程，这个进程会不断的写，写完后在执行 Unlink 操作删除掉：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ stress -d 1<br>stress: info: [18342] dispatching hogs: 0 cpu, 0 io, 0 vm, 1 hdd<br><br><span class="hljs-comment"># iostat 命令需要下载 sysstat 包，下载命令为 yum install -y sysstat</span><br>$ iostat -m  1<br>avg-cpu:  %user   %nice %system %iowait  %steal   %idle<br>           0.50    0.00   27.89    4.02    0.00   67.59<br><br>Device:            tps    MB_read/s    MB_wrtn/s    MB_read    MB_wrtn<br>sda             688.00         0.00       344.00          0        344<br>scd0              0.00         0.00         0.00          0          0<br>dm-0            688.00         0.00       344.00          0        344<br>dm-1              0.00         0.00         0.00          0          0<br></code></pre></td></tr></table></figure><p>可以发现，磁盘写操作占用磁盘写资源。</p><h3 id="如何在容器内使用-Stress-工具"><a href="#如何在容器内使用-Stress-工具" class="headerlink" title="如何在容器内使用 Stress 工具"></a>如何在容器内使用 Stress 工具</h3><p>我们可以在容器内挂载 <code>stress</code> 命令来达到在容器内进行压测的目的了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 我们先用一个 --cpus 参数来限制容器使用的 CPU 个数来测试</span><br>$ docker run --rm -it --cpus 0.5 --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,src=/usr/bin/stress,dst=/usr/bin/stress centos:7 stress -c 4<br>stress: info: [1] dispatching hogs: 4 cpu, 0 io, 0 vm, 0 hdd<br><br><span class="hljs-comment"># 在另一个终端使用 top 命令</span><br>$ top<br>...<br>%Cpu(s): 12.6 us,  0.0 sy,  0.0 ni, 87.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>...<br>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<br>19205 root      20   0    7308    100      0 R  12.6  0.0   0:09.87 stress<br>19206 root      20   0    7308    100      0 R  12.6  0.0   0:09.96 stress<br>19203 root      20   0    7308    100      0 R  12.3  0.0   0:09.89 stress<br>19204 root      20   0    7308    100      0 R  12.3  0.0   0:09.86 stress<br></code></pre></td></tr></table></figure><p>但是这样做有些麻烦，我们可以制作一个封装了 <code>stress</code> 命令的容器。这样，也省的在宿主机上下载 Stress 工具包了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 tree 命令查看文件树需要下载 tree 包，下载命令为 yum install -y tree</span><br>$ tree<br>.<br>└── Dockerfile<br><br>0 directories, 1 file<br><br>$ cat Dockerfile <br>FROM centos:7<br>MAINTAINER Peng.Gao &lt;jugg.gao@qq.com&gt;<br><br>RUN yum install -y epel-release &amp;&amp; yum install -y stress<br><br>ENTRYPOINT [<span class="hljs-string">"/usr/bin/stress"</span>]<br>CMD [<span class="hljs-string">"--help"</span>]<br><br>$ docker image build -t jugggao/stress:1.0 .<br>Sending build context to Docker daemon  2.048kB<br>Step 1/5 : FROM centos:7<br> ---&gt; 1e1148e4cc2c<br>Step 2/5 : MAINTAINER Peng.Gao &lt;jugg.gao@qq.com&gt;<br> ---&gt; Using cache<br> ---&gt; 4129b0988155<br>...<br>Successfully tagged jugggao/stress:1.0<br><br>$ docker image ls<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>jugggao/stress      1.0                 47f7f30d7bc6        7 minutes ago       317MB<br></code></pre></td></tr></table></figure><p>使用 Dockerfile 来制作 Docker 镜像以后我会讲到，做完镜像以后在容器内使用 <code>stress</code> 命令就方便多了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --cpus 1 jugggao/stress:1.0 -c 2<br>stress: info: [1] dispatching hogs: 2 cpu, 0 io, 0 vm, 0 hdd<br><br>$ top<br>...<br>%Cpu(s): 25.0 us,  0.1 sy,  0.0 ni, 74.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>...<br>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<br>21610 root      20   0    7308     96      0 R  50.2  0.0   1:33.93 stress<br>21611 root      20   0    7308     96      0 R  49.5  0.0   1:33.45 stress<br></code></pre></td></tr></table></figure><p>因为这个镜像指定的入口（ENTRYPOINT）为 <code>/usr/bin/stress</code> 命令，所以我们连命令都不需要指定了，直接指定对应的参数即可。这个镜像我已经上传到我的 Docker Hub 中，想直接使用的话可以使用以下命令下载：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker pull jugggao/stress:1.0<br></code></pre></td></tr></table></figure><h2 id="CPU-限制"><a href="#CPU-限制" class="headerlink" title="CPU 限制"></a>CPU 限制</h2><p>限制 CPU 资源的参数有很多：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">--cpu-period  <span class="hljs-comment"># 与 --cpu-quota 结合使用，用于指定 CPU 从新分配资源的时间周期，时间周期结束后，会对CPU 进行重新分配</span><br>--cpu-quota  <span class="hljs-comment"># 与 --cpu-period 结合使用，于设定该容器在资源分配周期内占用 CPU 的时间</span><br>--cpu-rt-period  <span class="hljs-comment"># --cpu-period 的微秒版，指定 CPU 重新分配资源的的时间周期 </span><br>--cpu-rt-runtime  <span class="hljs-comment"># 在一个 CPU 资源分配周期内，优先保证容器的 CPU 使用的最大微秒数</span><br>-c, --cpu-shares  <span class="hljs-comment"># 设置容器 CPU 权重，可以用于调整容器在单位分配周期内的资源优先使用比</span><br>--cpus  <span class="hljs-comment"># 设置容器使用 CPU 的数量，用于快速设置容器对于 CPU 的占用</span><br>--cpuset-cpus  <span class="hljs-comment"># 将容器绑定在指定的 CPU 上运行，可以设置范围（0-3），也可以绑定多个（ 0,2）</span><br>--cpuset-mems  <span class="hljs-comment"># 将容器绑定在指定的内存节点，每个内存节点和 NUMA 节点一一对应</span><br></code></pre></td></tr></table></figure><p>这里只介绍 <code>--cpus</code> 与 <code>--cpuset-cpus</code> 这两个参数。</p><h3 id="限制容器最多能使用的-CPU-核数"><a href="#限制容器最多能使用的-CPU-核数" class="headerlink" title="限制容器最多能使用的 CPU 核数"></a>限制容器最多能使用的 CPU 核数</h3><p>Docker 提供了 <code>--cpus</code> 参数可以限定容器能使用的 CPU 核数。这个功能可以让我们精确的设置 CPU 容器使用量。相比于 <code>--cpu-period</code> 参数与 <code>--cpu-quota</code> 参数结合使用，这个参数也更容易理解。</p><p><code>--cpus</code> 后面跟一个浮点数，代表容器最多可以使用的 CPU 核数，可以精确到小数点二位，也就是说容器最小可以设置最多使用 0.01 核 CPU。比如我们现在有 4 个核心，限制容器最多能使用 2 个核心：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --cpus 2 jugggao/stress:1.0 -c 4<br>stress: info: [1] dispatching hogs: 4 cpu, 0 io, 0 vm, 0 hdd<br><br><span class="hljs-comment"># 由于容器名是随机的，查询一下容器的 ID</span><br>$ docker container ls<br>CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS              PORTS               NAMES<br>385ddca16804        jugggao/stress:1.0   <span class="hljs-string">"/usr/bin/stress -c 4"</span>   6 seconds ago       Up 5 seconds                            gracious_keldysh<br><br><span class="hljs-comment"># 在另一个终端使用 docker container stats 查询容器占用的资源</span><br>$ docker container stats 385ddca16804<br>CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS<br>385ddca16804        gracious_keldysh    199.57%             192KiB / 7.638GiB   0.00%               656B / 0B           24.6kB / 0B         5<br><br><span class="hljs-comment"># 我们使用 htop 更人性化显示主机资源使用情况</span><br>$ htop<br></code></pre></td></tr></table></figure><p><img src="/images/CPU使用核心数限制.png" alt="CPU 使用核心数限制"></p><p>我们在容器内启动了 4 个 CPU 进程，如果不做限制的话，这个容器会把宿主机上的 CPU 资源全部吃完。但是我们添加了 <code>--cpus 2</code> 这个限制，无论容器启动多少个进程，最多只能占用宿主机的 2 个 cpu 核心数，即宿主机 CPU 资源的 50%。</p><h3 id="限制容器运行在固定的-CPU-核心上"><a href="#限制容器运行在固定的-CPU-核心上" class="headerlink" title="限制容器运行在固定的 CPU 核心上"></a>限制容器运行在固定的 CPU 核心上</h3><p>现在的服务器或个人电脑都会有多个 CPU，Docker 也允许调度资源的时候限制容器运行在哪个 CPU 核心上。</p><p>比如我的主机有 4 个核心（0,1,2,3），现在有一些不太重要的容器（比如说需要一些大量的 I/O 操作，不需要执行的很快，优先级不是很高），我希望这些不太重要的容器共用最后 2 个核心，达到不影响其他重要的容器的目的。那么我们可以通过 <code>--cpuset-cpus</code> 参数让这些容器只运行在固定的 CPU 核心上：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --cpuset-cpus 2,3 jugggao/stress:1.0 -c 4<br>stress: info: [1] dispatching hogs: 4 cpu, 0 io, 0 vm, 0 hdd<br><br>$ htop<br></code></pre></td></tr></table></figure><p><img src="/images/绑定固定CPU核心.png" alt="绑定固定 CPU 核心"></p><p>我们在容器内启动的 CPU 进程只在 2 和 3 这两个 CPU 核心上运行了。</p><p>我们还可以指定一段 CPU 核心的范围：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --cpuset-cpus 2-3 jugggao/stress:1.0 -c 4<br></code></pre></td></tr></table></figure><h2 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h2><p>默认情况下，Docker 不会对容器的内存进行限制，容器可以使用主机提供的所有内存。这是一件比较危险的事情，我在工作中遇见了不少代码内存泄漏导致系统主机内存耗尽，导致服务不可用。前段时间公司的一台阿里云服务器中了恶意程序不断的运行 Crontab 定时任务进行内存恶意消耗导致 OOM ，系统崩溃。 </p><blockquote><p>注： Docker 会设置 Docker Daemon 的 OOM（Out Of Memory）值，使其在内存不足的时候被杀死的优先级降低，因为如果 Docker Daemon 由于 OOM 的问题被 Linux 内核干掉了，那么这台服务器所有容器都不能再使用了，所以在内存不足的时候 Docker Daemon 应该排在容器进程后面被杀死才比较合理。</p></blockquote><p>对于这种情况，我们可以为每个容器设置内存的使用上限，一旦超过这个上限，容器就会被杀死，而不是耗尽主机的内存资源。</p><p>注意，限制内存上限虽然能保护主机，但也可能会伤害容器内的服务。如果为服务设置的内存上限太小，会导致服务还在正常工作的时候就会因为 OOM 被 Kill 掉；如果设置的过大，会因为调度器算法浪费内存。</p><p>因此，合理的做法包括：</p><ul><li><p>为应用做内存压力测试，理解业务正常时需求的使用内存资源量，然后再为容器做内存限制;</p></li><li><p>尽量保证主机的资源充足，一旦通过监控发现资源不足，就进行扩容或者对容器进行迁移（这点 Kubernetes 可以优雅的解决）;</p></li><li><p>进来不要使用 Swap 内存交换空间，Swap 交换空间的使用会导致内存计算复杂，对调度器非常不友好（Kubernetes 默认是必须禁用 Swap 交换空间的）。</p></li></ul><p>Docker 限制容器内存使用量有以下参数：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-m, --memory  <span class="hljs-comment"># 限制容器的内存使用量</span><br>--memory-reservation  <span class="hljs-comment"># 软限制容器的内存使用量，达到软限制的容器不会进行 OOM，但是如果 Docker 发现主机内存不足，会执行 OOM 操作优先 Kill 掉容器里的进程。这个值必须小于 --memory 设置的值</span><br>--memory-swap  <span class="hljs-comment"># 限制容器的总内存的使用量，包括物理内存和交换分区</span><br>--memory-swappiness  <span class="hljs-comment"># 默认情况下，主机可以把容器使用的匿名页（Anonymous Page）Swap 出来，你可以设置一个 0-100 之间的值，代表允许 Swap 出来的比例。默认情况下这个值会从宿主机继承</span><br>--kernel-memory  <span class="hljs-comment"># 限制容器的内核内存使用量</span><br>--oom-kill-disable  <span class="hljs-comment"># 默认情况下，如果内存不足，内核或终止容器内的进程。如果设置了此参数，内存不足时也不会终止容器内的进程，此时系统会 Kill 系统进程用于释放进程。这个参数比较危险，慎用。</span><br></code></pre></td></tr></table></figure><p>这里只介绍 <code>-m</code> 参数与 <code>--memory-swap</code> 参数。</p><h3 id="限制容器内存使用量"><a href="#限制容器内存使用量" class="headerlink" title="限制容器内存使用量"></a>限制容器内存使用量</h3><p>Docker 提供了 <code>-m</code> 或 <code>--memory</code> 参数来限制容器内存最大的使用量。我们来启动一个 Stress 容器并启动占用 4G 的内存分配进程，并把这个容器的内存上限限制为 2G，观察一下结果：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it  -m 2g  jugggao/stress:1.0 --vm 2 --vm-bytes 2G --vm-keep<br>stress: info: [1] dispatching hogs: 0 cpu, 0 io, 2 vm, 0 hdd<br>stress: FAIL: [1] (415) &lt;-- worker 8 got signal 9<br>stress: WARN: [1] (417) now reaping child worker processes<br>stress: FAIL: [1] (451) failed run completed <span class="hljs-keyword">in</span> 4s<br></code></pre></td></tr></table></figure><p>容器内的进程由于超过了设置的内存上限导致 OOM，进程被 Kill 掉（信号 9）。</p><h3 id="限制容器内交换空间使用量"><a href="#限制容器内交换空间使用量" class="headerlink" title="限制容器内交换空间使用量"></a>限制容器内交换空间使用量</h3><p>Docker 提供了 <code>--memory-swap</code> 参数来配置容器内的物理内存和交换空间总和的使用上限。关于这个参数的用法如下：</p><ul><li><p>如果设置了 <code>--memory-swap</code>  并且为正整数，那么也必须设置 <code>-m</code> 或 <code>--memory</code> 的值;</p></li><li><p><code>--memory-swap</code> 的值必须大于 <code>--memory</code> 的值，并且容器可用交换分区为：「交换分区」 = 「–memory-swap 设置的值」 - 「–memory-swap 设置的值」。比如设置了 <code>--memory 2g --memory-swap 6g</code>，容器内的可用交换分区为 4G;</p></li><li><p><code>--memory-swap</code> 的值为 0；或 <code>--memory-swap</code> 的值与 <code>--memory</code> 的值相同；或未指定 <code>--memory-swap</code> 参数，表示禁用容器内的交换分区使用;</p></li><li><p><code>--memory-swap</code> 的值为 -1 表示不限制容器内交换分区的使用，主机有多少 Swap 交换空间，容器就能用多少。</p></li></ul><p>我们给容器分配 4G 的交换分区的使用来在看下是否还会导致容器内的进程因为 OOM 被 Kill 掉：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it  -m 2g  --memory-swap 6g jugggao/stress:1.0 --vm 2 --vm-bytes 2G --vm-keep<br>stress: info: [1] dispatching hogs: 0 cpu, 0 io, 2 vm, 0 hdd<br><br>$ docker container ls <br>CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS              PORTS               NAMES<br>62f39d1bed21        jugggao/stress:1.0   <span class="hljs-string">"/usr/bin/stress --v…"</span>   48 seconds ago      Up 47 seconds                           unruffled_jepsen<br><br>$ docker container stats 62f39d1bed21<br>CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS<br>62f39d1bed21        unruffled_jepsen    50.68%              2GiB / 2GiB         99.99%              656B / 0B           13.7GB / 10.4GB     3<br><br>$ free -m<br>              total        used        free      shared  buff/cache   available<br>Mem:           7821        2296        5178           8         346        5245<br>Swap:          8191        2051        6140<br></code></pre></td></tr></table></figure><p>可以看到，容器内使用的最大内存已经达到了 2G，并且使用了 2G 的交换分区内存。</p><p>不建议为容器配置交换分区，交换分区性能很低。可以在宿主机上配置 Swap 提供缓冲以防止系统内存资源耗尽而导致的系统崩溃。</p><h2 id="磁盘限制"><a href="#磁盘限制" class="headerlink" title="磁盘限制"></a>磁盘限制</h2><p>对于磁盘来说，考量的参数是磁盘的容量与读写速度。因此对容器的磁盘限制也应该从这两个指标出发。</p><p>Docker 目前支持对磁盘读写速度进行限制，但是并不支持对磁盘容量进行限制，一旦磁盘挂载到容器里，容器就能够使用磁盘所有的容量。</p><h3 id="限制磁盘读写速率"><a href="#限制磁盘读写速率" class="headerlink" title="限制磁盘读写速率"></a>限制磁盘读写速率</h3><p>Docker 提供了两个参数来限制容器内磁盘的读写速率：</p><ul><li><p><code>--device-read-bps</code>：限制磁盘读取速率;</p></li><li><p><code>--device-write-bps</code>：限制磁盘写入速率。</p></li></ul><p>上面两个参数的值都是磁盘对应的速率，格式为 <code>&lt;deivce-path&gt;:&lt;limit&gt;[unit]</code>，其中 <code>&lt;device-path&gt;</code> 表示磁盘所在位置，<code>&lt;limit&gt;</code> 表示限制的速率，后面的单位 <code>[unit]</code> 可以为 kb、mb、和 gb。</p><p>比如我们把一个容器的磁盘设备读速率限制为 5 MB/s：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm  -it  --device-read-bps /dev/sda:5mb centos:7 \<br>    dd iflag=direct,nonblock <span class="hljs-keyword">if</span>=/dev/zero of=/dev/null bs=5M count=10<br>10+0 records <span class="hljs-keyword">in</span><br>10+0 records out<br>52428800 bytes (52 MB) copied, 50.0026 s, 1.0 MB/s<br></code></pre></td></tr></table></figure><p>可以看到，从盘读取 50M 的数据，一共花费了 50s 左右，每秒读取 1MB。</p><p>把磁盘的写速率限制为 1 MB/s：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --device-write-bps /dev/sda:1mb centos:7 \<br>    dd oflag=direct,nonblock <span class="hljs-keyword">if</span>=/dev/zero of=/tmp/<span class="hljs-built_in">test</span> bs=5M count=10<br>10+0 records <span class="hljs-keyword">in</span><br>10+0 records out<br>52428800 bytes (52 MB) copied, 50.0059 s, 1.0 MB/s<br></code></pre></td></tr></table></figure><p>可以看到，写入 50M 的数据到磁盘空间，一共花费了 50s 左右，每秒读取 1MB。</p><h3 id="限制磁盘读写频率"><a href="#限制磁盘读写频率" class="headerlink" title="限制磁盘读写频率"></a>限制磁盘读写频率</h3><p>Docker 还提供了两个参数来限制磁盘的读写频率：</p><ul><li><p><code>--device-read-iops</code>：磁盘每秒最多可以执行多少 IO 读操作；</p></li><li><p><code>--device-write-iops</code>：磁盘每秒最多可以执行多少 IO 写操作。</p></li></ul><p>上面两个参数的值都是磁盘以及对应的 IO 上限，格式为 <code>&lt;device-path&gt;:&lt;limit&gt;</code>，<code>&lt;limit&gt;</code> 为正整数，表示磁盘 IO 上限数。</p><p>我们来限制容器磁盘设备每秒最多读 100 次：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -it --device /dev/sda:/dev/sda --device-read-iops /dev/sda:100 centos:7 \<br>    dd iflag=direct,nonblock <span class="hljs-keyword">if</span>=/dev/sda of=/dev/null bs=1k count=1000<br>1000+0 records <span class="hljs-keyword">in</span><br>1000+0 records out<br>1024000 bytes (1.0 MB) copied, 9.91246 s, 103 kB/s<br></code></pre></td></tr></table></figure><p>因为我们制定了 bs 这个参数为 1k，表示一次读写 1K 的数据，所以我们指定一共要读 1000 次，一共用了 10s，符合预期。</p><p><code>--device-write-iops</code> 参数与 <code>--device-read-iops</code> 参数类似，就不再说明。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Docker 中可以限制的资源有：</p><ol><li><p>CPU 限制，主要使用 <code>--cpus</code> 参数来限制容器最多使用的 CPU 核心数。</p></li><li><p>内存限制，主要使用 <code>-m</code> 参数来限制容器最多能使用的内存量。使用内存限制的时候一定要考虑业务实际内存的使用量再根据实际情况进行限制。</p></li><li><p>磁盘限制，主要使用 <code>--device-read-bps</code> 参数与 <code>--device-write-bps</code> 参数来限制容器内磁盘读写速率。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://docs.docker.com/config/containers/resource_constraints/#--memory-swappiness-details" target="_blank" rel="noopener">Limit a container’s resources</a></p></li><li><p><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener">Docker run reference</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
          <category> Dokcer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 数据卷的使用与挂载主机目录</title>
      <link href="/2019/03/22/Docker/1.6%20Docker%20%E5%86%85%E6%A0%B8%E8%83%BD%E5%8A%9B%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/22/Docker/1.6%20Docker%20%E5%86%85%E6%A0%B8%E8%83%BD%E5%8A%9B%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-6-Docker-内核能力配置"><a href="#1-6-Docker-内核能力配置" class="headerlink" title="1.6 Docker 内核能力配置"></a>1.6 Docker 内核能力配置</h1><p>Linux 内核定义了一些特殊的权限，即所谓的<strong>能力（Capability）</strong>，把这些权限分配给进程后，进程就能够获得更多的系统权限。可用的内核能力涵盖广泛的功能，从更改系统时间到开启网络套接字。所以如果某个进程拥有完全的 Root 权限，即拥有所有的内核能力，那么这个进程是很危险的，很可能被攻击者利用，并获得系统的 Root 权限。</p><p>我们可以使用 <code>getcap</code> 命令获取程序所拥有的 Linux 内核功能。比如说 Ping 这个程序，执行时只需要获取一些关于网络的内核权限，所以默认会给 Ping 分配有限的权限使你使用 Ping 的时候更加安全：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">getcap</span> /bin/ping<br>/bin/ping = cap_net_admin,cap_net_raw+p<br></code></pre></td></tr></table></figure><p>我们也可以使用 <code>getpcaps</code> 来获取进程所拥有的 Linux 内核功能。比如说 NetworkManaget 这个进程所拥有的 Linux 内核功能为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -ef | grep -v grep | grep NetworkManager<br>root      5745     1  0 Feb19 ?        00:00:03 /usr/sbin/NetworkManager --no-daemon<br><br>$ getpcaps 5745<br>Capabilities <span class="hljs-keyword">for</span> `5745<span class="hljs-string">': = cap_dac_override,cap_kill,cap_setgid,cap_setuid,cap_net_bind_service,cap_net_admin,cap_net_raw,cap_sys_module,cap_sys_chroot,cap_sys_admin,cap_audit_write+ep</span><br></code></pre></td></tr></table></figure><p>相关 Linux 内核功能参考<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">capabilities(7) - Linux man page</a>。</p><p>我们之前介绍过，容器的本质其实就是一个进程。那么容器自然也可以获取或者限制 Linux 内核的能力。</p><p>容器对于 Linux 内核能力配置的使用非常少，但是有些情况又很重要：</p><ul><li><p>比如说容器内的时间是无法隔离的，和宿主机的时间是共享的，但是容器内是不能修改系统时间的，必须要为容器加上修改时间的内核能力（SYS_TIME）才能修改系统时间，这对于需要能修改时间的容器（NTP 容器）是很重要的；</p></li><li><p>比如说容器内是没办法修改网络的，如果想在某个容器内管理网络，也必须加上网络管理的内核能力（NET_ADMIN）才能修改网络。</p></li></ul><p>还有一种情况，如果对安全性要求很高的公司，限制容器的 Linux 内核能力将会大幅度的提高系统的安全性。</p><p>我们这里只是简单介绍容器对于 Linux 内核能力的配置，只是为了容器内运行某个程序时出现权限不足时能够想到为容器提权。</p><h2 id="容器默认授权的内核功能"><a href="#容器默认授权的内核功能" class="headerlink" title="容器默认授权的内核功能"></a>容器默认授权的内核功能</h2><p>默认情况下，Docker 容器是「非特权」的，即不是拥有完全的 Root 权限。</p><p>我们来看下 Docker 默认拥有的 Linux 内核功能：</p><table><thead><tr><th>Capability Key</th><th>Capability Description</th></tr></thead><tbody><tr><td>SETPCAP</td><td>允许修改其他进程内核能力（容器主进程只能看到子进程也就是容器内的进程）</td></tr><tr><td>MKNOD</td><td>允许使用 mknod(2) 创建特殊文件（设备文件）</td></tr><tr><td>AUDIT_WRITE</td><td>允许向内核审计日志写入记录</td></tr><tr><td>CHOWN</td><td>允许改变文件的所有权（可以参考 chown 命令）</td></tr><tr><td>NET_RAW</td><td>允许使用 RAW 与 套接字（即 IP:Port）</td></tr><tr><td>DAC_OVERRIDE</td><td>允许忽略文件的读、写和执行权限的检查（即忽略文件的 DAC 访问限制）</td></tr><tr><td>FOWNER</td><td>允许忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td></tr><tr><td>FSETID</td><td>允许设置文件的 setuid 位（参考 chmod 命令）</td></tr><tr><td>KILL</td><td>允许对不属于自己的进程发送信号（参考 kill 命令）</td></tr><tr><td>SETGID</td><td>允许改变进程的组 ID</td></tr><tr><td>SETUID</td><td>允许改变进程的用户 ID</td></tr><tr><td>NET_BIND_SERVICE</td><td>允许将套接字（IP:Port）绑定特权接口（即端口号 Port 小于 1024）</td></tr><tr><td>SYS_CHROOT</td><td>允许改变进程的根目录（参考 chroot 命令）</td></tr><tr><td>SETFCAP</td><td>允许修改文件的内核能力（参考 setcap 命令）</td></tr></tbody></table><p>我们可以使用 <code>pscap</code> 来获取容器默认的内核能力：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d --name nginx nginx:1.14.2<br>a1919f19e91fb89c5d15aaa02f457cc6d1cf41d163140adbdd033401cc628d3a<br><br>$ ps -ef | grep -v grep |grep nginx<br>root     12028 12009  0 Feb20 ?        00:00:00 nginx: master process nginx -g daemon off;<br>101      12068 12028  0 Feb20 ?        00:00:00 nginx: worker process<br><br><span class="hljs-comment"># pscap 会更加友好的显示 Linux 内核功能，使用 pscap 需要下载 libcap-ng-utils 包，下载命令为 yum install -y libcap-ng-utils</span><br>$ pscap | awk <span class="hljs-string">'NR==1 || /12028/ &#123; print &#125;'</span><br>ppid  pid   name        <span class="hljs-built_in">command</span>           capabilities<br>12009 12028 root        nginx             chown, dac_override, fowner, fsetid, <span class="hljs-built_in">kill</span>, setgid, setuid, setpcap, net_bind_service, net_raw, sys_chroot, mknod, audit_write, setfcap<br></code></pre></td></tr></table></figure><h2 id="容器默认未授权的内核功能"><a href="#容器默认未授权的内核功能" class="headerlink" title="容器默认未授权的内核功能"></a>容器默认未授权的内核功能</h2><p>我们再来看容器默认未被授权的内核功能：</p><table><thead><tr><th>Capability Key</th><th>Capability Description</th></tr></thead><tbody><tr><td>SYS_MODULE</td><td>允许加载和卸载内核模块</td></tr><tr><td>SYS_RAWIO</td><td>允许修改内存</td></tr><tr><td>SYS_PACCT</td><td>允许打开或者关闭进程审计</td></tr><tr><td>SYS_ADMIN</td><td>允许执行一系列的系统管理操作，包括卸载挂载文件系统、配置磁盘配额、打开关闭交换分区等</td></tr><tr><td>SYS_NICE</td><td>允许修改进程的 Nice 值，即进程的调度策略与优先级</td></tr><tr><td>SYS_RESOURCE</td><td>允许忽略资源限制</td></tr><tr><td>SYS_TIME</td><td>允许修改系统时间与硬件时间</td></tr><tr><td>SYS_TTY_CONFIG</td><td>允许配置 TTY 设备</td></tr><tr><td>AUDIT_CONTROL</td><td>允许启动或关闭并配置内核审计系统</td></tr><tr><td>MAC_ADMIN</td><td>允许配置 MAC 地址</td></tr><tr><td>MAC_OVERRIDE</td><td>忽略 MAC 访问控制策略</td></tr><tr><td>NET_ADMIN</td><td>允许进行一系列的网络配置，包括接口配置、IP 防火墙配置、路由配置、代理配置等</td></tr><tr><td>SYSLOG</td><td>允许进行系统日志相关操作</td></tr><tr><td>DAC_READ_SEARCH</td><td>允许忽略文件的读权限检查和目录的读权限检查</td></tr><tr><td>LINUX_IMMUTABLE</td><td>允许修改文件的 FS_APPEND_FL（只能添加）和 FS_IMMUTABLE_FL（不可修改）标记</td></tr><tr><td>NET_BROADCAST</td><td>允许网络广播和多播访问</td></tr><tr><td>IPC_LOCK</td><td>允许锁定共享片段</td></tr><tr><td>IPC_OWNER</td><td>允许忽略 IPC 对象权限检查</td></tr><tr><td>SYS_PTRACE</td><td>允许跟踪、检查进程并允许进程的内存数据传输</td></tr><tr><td>SYS_BOOT</td><td>允许重新启动系统并加载新的内核</td></tr><tr><td>LEASE</td><td>允许修改文件锁的 FL_LEASE 标记，即修改文件租约</td></tr><tr><td>WAKE_ALARM</td><td>允许触发唤醒系统的定时器</td></tr><tr><td>BLOCK_SUSPEND</td><td>允许阻塞系统挂起</td></tr></tbody></table><p>我们时使用默认分配内核功能来启动一个容器看下有哪些功能是不能使用的：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it  centos:7 /bin/bas<br>[root@6d9d1f70bffb /]<span class="hljs-comment"># date -s 15:22:22</span><br>date: cannot <span class="hljs-built_in">set</span> date: Operation not permitted<br><br>[root@6d9d1f70bffb /]<span class="hljs-comment">#ls /dev/</span><br>console  core  fd  full  mqueue  null  ptmx  pts  random  shm  stderr  stdin  stdout  tty  urandom  zero<br></code></pre></td></tr></table></figure><p>可以看到，在容器内无法修改系统时间、无法看到硬件设备等等。</p><h2 id="配置容器的内核功能"><a href="#配置容器的内核功能" class="headerlink" title="配置容器的内核功能"></a>配置容器的内核功能</h2><p>Docker 提供了以下参数来修改容器的 Linux 内核功能：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">--<span class="hljs-built_in">cap</span>-add  <span class="hljs-comment"># 添加 Linux 内核功能</span><br>--<span class="hljs-built_in">cap</span>-drop  <span class="hljs-comment"># 删除 Linux 内核功能</span><br>--privileged  <span class="hljs-comment"># 添加此参数容器将获得 Root 权限，即拥有所有的内核功能</span><br>--device  <span class="hljs-comment"># 在不使用 --privileged 参数的情况下，此参数将允许你可以访问指定的设备</span><br></code></pre></td></tr></table></figure><p>我们分别来介绍这几个参数。</p><h3 id="配置容器特权模式"><a href="#配置容器特权模式" class="headerlink" title="配置容器特权模式"></a>配置容器特权模式</h3><p>在容器启动时如果添加了 <code>--privileged</code> 参数，那么容器将获得特权，即拥有所有的 Linux 内核功能，还包括访问宿主机所有的设备。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --rm -it --privileged centos:7 /bin/bash<br></code></pre></td></tr></table></figure><p>如果拥有了所有的 Linux 内核功能，那么这个容器就可以为所欲为。</p><p>比如说可以访问宿主机内所有的设备并创建或者修改或创建设备：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@5a4f3eb07bc9 /]<span class="hljs-comment"># ls /dev/</span><br>agpgart          crash  hpet          mqueue              ppp     sda2      stdin   tty13  tty20  tty28  tty35  tty42  tty5   tty57  tty7   uinput   vcs5   vcsa6<br>autofs           dm-0   hwrng         net                 ptmx    sg0       stdout  tty14  tty21  tty29  tty36  tty43  tty50  tty58  tty8   urandom  vcs6   vfio<br>bsg              dm-1   input         network_latency     pts     sg1       tty     tty15  tty22  tty3   tty37  tty44  tty51  tty59  tty9   usbmon0  vcsa   vga_arbiter<br>btrfs-control    dri    kmsg          network_throughput  random  shm       tty0    tty16  tty23  tty30  tty38  tty45  tty52  tty6   ttyS0  vcs      vcsa1  vhci<br>console          fb0    loop-control  null                raw     snapshot  tty1    tty17  tty24  tty31  tty39  tty46  tty53  tty60  ttyS1  vcs1     vcsa2  vhost-net<br>core             fd     mapper        nvram               rtc0    snd       tty10   tty18  tty25  tty32  tty4   tty47  tty54  tty61  ttyS2  vcs2     vcsa3  vmci<br>cpu              full   mcelog        oldmem              sda     sr0       tty11   tty19  tty26  tty33  tty40  tty48  tty55  tty62  ttyS3  vcs3     vcsa4  zero<br>cpu_dma_latency  fuse   mem           port                sda1    stderr    tty12   tty2   tty27  tty34  tty41  tty49  tty56  tty63  uhid   vcs4     vcsa5<br><br>$ fdisk /dev/sda<br>Welcome to fdisk (util-linux 2.23.2).<br><br>Changes will remain <span class="hljs-keyword">in</span> memory only, until you decide to write them.<br>Be careful before using the write <span class="hljs-built_in">command</span>.<br><br><br>Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):<br></code></pre></td></tr></table></figure><p>比如说我们也可以修改系统时间：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">date -s 11:45<br>Thu Feb 21 11:45:00 UTC 2019<br></code></pre></td></tr></table></figure><p>但添加 <code>--privileged</code> 参数来启动容器是很危险的一件事，如果攻击者能进入你的容器，那么他就可以很轻松的攻击宿主机系统了。</p><p>因此不建议使用 <code>--privileged</code> 这个参数，除非你只是想确定你的容器内出现的问题是否是因为 Linux 内核功能不足导致的，可以使用此参数来进行验证。</p><h3 id="添加或删除容器指定的内核功能"><a href="#添加或删除容器指定的内核功能" class="headerlink" title="添加或删除容器指定的内核功能"></a>添加或删除容器指定的内核功能</h3><p>我们可以使用 <code>--cap-add</code> 或 <code>--cap-drop</code> 按照需求为容器添加或删除指定的内核功能：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --rm -ti --<span class="hljs-built_in">cap</span>-add SYS_TIME centos:7 /bin/bash<br>[root@8f1df0bcd091 /]<span class="hljs-comment"># date -s 13:52:00</span><br>Thu Feb 21 13:52:00 UTC 201<br></code></pre></td></tr></table></figure><p>也可以添加所有的 Linux 内核功能，但无法访问宿主机的设备：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --rm -ti --<span class="hljs-built_in">cap</span>-add ALL centos:7 /bin/bash<br>[root@947367204d1c /]<span class="hljs-comment"># ls /dev/</span><br>console  core  fd  full  mqueue  null  ptmx  pts  random  shm  stderr  stdin  stdout  tty  urandom  zero<br></code></pre></td></tr></table></figure><p>如果想让一个容器安全性大幅度的提升，我们通常采取以下做法：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 80:80 \<br>    --<span class="hljs-built_in">cap</span>-drop ALL --<span class="hljs-built_in">cap</span>-add CHOWN --<span class="hljs-built_in">cap</span>-add NET_BIND_SERVICE --<span class="hljs-built_in">cap</span>-add SETGID --<span class="hljs-built_in">cap</span>-add SETUID \<br>    --name nginx nginx:1.14.2<br>4a1737b5a07ea107c6cd15e00880fd1fd2385d5933b73fee3eda488a82ffb8cd<br><br>$ pscap<br>...<br>17066 17085 root        nginx             chown, setgid, setuid, net_bind_service<br></code></pre></td></tr></table></figure><p>那么有个问题，怎么知道一个容器究竟需要哪些 Linux 内核功能呢？</p><p>不断的尝试和修正似乎是最简单的方法：</p><ol><li><p>首先，Nginx 容器肯定需要绑定端口，并且端口为 80，小于 1024。因此我首先想到的第一个权限是：<code>NET_BIND_SERVICE</code>：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --rm -it -p 80:80 --<span class="hljs-built_in">cap</span>-drop ALL --<span class="hljs-built_in">cap</span>-add NET_BIND_SERVICE nginx:1.14.2<br>2019/02/21 14:30:26 [emerg] 1<span class="hljs-comment">#1: chown("/var/cache/nginx/client_temp", 101) failed (1: Operation not permitted)</span><br>nginx: [emerg] chown(<span class="hljs-string">"/var/cache/nginx/client_temp"</span>, 101) failed (1: Operation not permitted)<br></code></pre></td></tr></table></figure></li><li><p>Nginx 还需要创建临时文件并配置它们的属主，因此我们还需添加权限：<code>CHOWN</code>： </p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --rm -it -p 80:80 --<span class="hljs-built_in">cap</span>-drop ALL --<span class="hljs-built_in">cap</span>-add NET_BIND_SERVICE --<span class="hljs-built_in">cap</span>-add CHOWN nginx:1.14.2<br>2019/02/21 14:32:59 [emerg] 6<span class="hljs-comment">#6: setgid(101) failed (1: Operation not permitted)</span><br>2019/02/21 14:32:59 [alert] 1<span class="hljs-comment">#1: worker process 6 exited with fatal code 2 and cannot be respawned</span><br></code></pre></td></tr></table></figure></li><li><p>这样似乎运行起来了，但是 Nginx 的 Worker 进程还是 root 用户，还是少了权限能让 Nginx 主进程可以修改子进程的 GID 和 UID，所以我们还需要添加权限： <code>SETGID</code> 和 <code>SETUID</code>：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --rm -it -p 80:80 --<span class="hljs-built_in">cap</span>-drop ALL --<span class="hljs-built_in">cap</span>-add NET_BIND_SERVICE --<span class="hljs-built_in">cap</span>-add CHOWN --<span class="hljs-built_in">cap</span>-add SETGID --<span class="hljs-built_in">cap</span>-add SETUID nginx:1.14.2<br></code></pre></td></tr></table></figure></li></ol><p>至此，我们确认了 Nginx 容器所需要的 Linux 内核功能。</p><p>但也有可能漏掉一个容器进程很少会用到的权限，所以需要你对 Linux 内核功能还有程序所需要使用的内核功能有个全面的了解才能够游刃有余，能在提升容器安全性的同时又能保证程序正常运行。</p><h3 id="添加容器可以访问的设备"><a href="#添加容器可以访问的设备" class="headerlink" title="添加容器可以访问的设备"></a>添加容器可以访问的设备</h3><p>我们刚才使用 <code>--cap-add ALL</code> 参数也无法访问宿主机的设备，那么如何在不使用 <code>--privileged</code> 参数的前提下，能够访问宿主机的设备呢。</p><p>我们可以使用 <code>--device</code> 将宿主机的设备映射至容器内，这样就可以在容器内访问到宿主机的设备了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --rm -it --device /dev/sda:/dev/sda  centos:7 /bin/bash<br>[root@63fa1358138d /]<span class="hljs-comment"># ls /dev/</span><br>console  core  fd  full  mqueue  null  ptmx  pts  random  sda  shm  stderr  stdin  stdout  tty  urandom  zero<br></code></pre></td></tr></table></figure><p>我们之前在使用压测时也映射过磁盘设备：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -it --device /dev/sda:/dev/sda --device-read-iops /dev/sda:100 centos:7 \<br>    dd iflag=direct,nonblock <span class="hljs-keyword">if</span>=/dev/sda of=/dev/null bs=1k count=1000<br>1000+0 records <span class="hljs-keyword">in</span><br>1000+0 records out<br>1024000 bytes (1.0 MB) copied, 9.91246 s, 103 kB/s<br></code></pre></td></tr></table></figure><p>所以，我们可以使用 <code>--cap-add</code> 与 <code>--device</code> 这两个参数的结合，达到一个需要基于设备创建文件系统的容器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>通常，对于安全性要求不高的容器，我们使用容器默认的 Linux 内核权限即可。</p></li><li><p>如果怀疑是容器内核功能权限不够导致重启内进程出现问题，我们可以使用 <code>--privileged</code> 开放容器所有的内核功能包括访问宿主机设备来确定是否是因为缺少内核功能导致的。但最好不要在生产环境中使用这个参数，会大幅度的降低容器的安全性。</p></li><li><p>如果为容器需要添加或者删除 Linux 内核功能或者访问设备，那么我们可以使用 <code>--cap-add</code> 和 <code>--cap-frop</code> 与 <code>--device</code> 参数结合使用。</p></li><li><p><code>--privileged</code> 等于 <code>--cap-add ALL</code> 加上 <code>--device</code> 映射所有的宿主机设备。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities" target="_blank" rel="noopener">Runtime privilege and Linux capabilities</a></p></li><li><p><a href="https://github.com/opencontainers/runc/tree/master/libcontainer" target="_blank" rel="noopener">Libcontainer Runc</a></p></li><li><p><a href="http://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">capabilities(7) - Linux man page</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
          <category> Dokcer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 容器和镜像的基本操作</title>
      <link href="/2019/03/22/Docker/1.2%20Docker%20%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/03/22/Docker/1.2%20Docker%20%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-2-Docker-容器和镜像的基本操作"><a href="#1-2-Docker-容器和镜像的基本操作" class="headerlink" title="1.2 Docker 容器和镜像的基本操作"></a>1.2 Docker 容器和镜像的基本操作</h1><p>首先，用一张图来概括 Docker 容器和镜像的一些常用命令。</p><p><img src="/images/Docker命令.png" alt="Docker 命令"></p><p>我们根据这幅图来介绍一下 Docker 的一些基本概念：</p><ul><li><p>镜像（Images）：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如环境变量、用户等）。</p></li><li><p>容器（Container）：镜像和容器的关系，就像是面对对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。</p></li><li><p>仓库（Docker Registry）：集中存储、分发镜像的服务。比如说 Docker Hub。</p></li></ul><p>接下来我们来根据这个图来说明一些 Docker 镜像和容器的一些基本操作方法。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>Docker 官方提供了一个公共的镜像仓库：<a href="https://hub.docker.com/search/?type=image" target="_blank" rel="noopener">Docker Hub</a>，我们可以从这上面获取镜像。</p><p>获取镜像的命令为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage:  docker image pull [OPTIONS] [Docker Registry[:Port]/]Name[:TAG]<br></code></pre></td></tr></table></figure><ul><li><p>Docker 镜像仓库地址：地址的格式一般是&lt;域名/IP&gt;[:端口]，如果不填写默认为 Docker Hub。</p></li><li><p>仓库名：仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不填写用户名，则默认为 Library，也就是官方镜像。</p></li><li><p>标签：对于同一个仓库名，可能会存在多个标签，即多个版本。如果不填写标签，默认为 latest 标签。</p></li></ul><p>比如，我们下载一个 CentOS 官方镜像：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image pull centos<br>Using default tag: latest<br>latest: Pulling from library/centos<br>a02a4930cb5d: Pull complete <br>Digest: sha256:184e5f35598e333bfa7de10d8fb1cebb5ee4df5bc0f970bf2b1e7c7345136426<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> centos:latest<br></code></pre></td></tr></table></figure><p>上面的命令没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像；也没有给出用户名，因此会从官方镜像库即 Library 获取 CentOS 镜像；也没有给出标签，因此会获取 latest 标签的 CentOS 镜像。</p><p>通常我们会指定标签获取指定版本的镜像：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image pull ubuntu:16.04<br>16.04: Pulling from library/ubuntu<br>7b722c1070cd: Pull complete <br>5fbf74db61f1: Pull complete <br>ed41cb72e5c9: Pull complete <br>7ea47a67709e: Pull complete <br>Digest: sha256:e4a134999bea4abb4a27bc437e6118fdddfb172e1b9d683129b74d254af51675<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> ubuntu:16.04<br></code></pre></td></tr></table></figure><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>获取完镜像，我们可以列出我们已经获取到的本地镜像。</p><p>列出镜像的命名为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage:  docker image ls [OPTIONS] [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure><p>例如，我们列出所有的镜像：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image ls<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>ubuntu              16.04               7e87e2b3bf7a        3 weeks ago         117MB<br>centos              7                   1e1148e4cc2c        2 months ago        202MB<br>centos              latest              1e1148e4cc2c        2 months ago        202MB<br></code></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>如果本地镜像仓库中的镜像有不需要用到的，我们可以删除镜像来释放出硬盘资源。</p><p>删除镜像的命令如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage:  docker image rm [OPTIONS] IMAGE [IMAGE...]<br></code></pre></td></tr></table></figure><p>比如，我们删除刚才下载的 centos:7 镜像：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image rm centos:7<br>Untagged: centos:7<br>Untagged: centos@sha256:184e5f35598e333bfa7de10d8fb1cebb5ee4df5bc0f970bf2b1e7c7345136426<br>Deleted: sha256:1e1148e4cc2c148c6890a18e3b2d2dde41a6745ceb4e5fe94a923d811bf82ddb<br>Deleted: sha256:071d8bd765171080d01682844524be57ac9883e53079b6ac66707e192ea25956<br></code></pre></td></tr></table></figure><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>有了 Docker 镜像后，我们就可以以这个镜像为基础启动并运行一个容器。</p><p>运行容器的命令为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage:  docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>以上面的 Ubuntu 16.04 镜像为例，我们来启动里面的 bash 并且进行交互式操作，可以执行以下命令。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -it --rm ubuntu:16.04 /bin/bash<br>root@f07761908385:/<span class="hljs-comment"># cat /etc/os-release </span><br>NAME=<span class="hljs-string">"Ubuntu"</span><br>VERSION=<span class="hljs-string">"16.04.5 LTS (Xenial Xerus)"</span><br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=<span class="hljs-string">"Ubuntu 16.04.5 LTS"</span><br>VERSION_ID=<span class="hljs-string">"16.04"</span><br>HOME_URL=<span class="hljs-string">"http://www.ubuntu.com/"</span><br>SUPPORT_URL=<span class="hljs-string">"http://help.ubuntu.com/"</span><br>BUG_REPORT_URL=<span class="hljs-string">"http://bugs.launchpad.net/ubuntu/"</span><br>VERSION_CODENAME=xenial<br>UBUNTU_CODENAME=xenial<br>root@afcf72ed65a5:/<span class="hljs-comment"># exit</span><br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>Run 命令的用法在以后会详细总结，先简要说明下上面用到的参数。</p><ul><li><p>-it：这是两个参数，一个是 -i，表示以交互模式运行容器；一个是 -t，表示为容器分配一个伪终端。通常这两个参数结合使用。我们需要进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</p></li><li><p>–rm：这个参数表示退出容器时会将容器删除。默认情况下，为了排障需求，退出容器不会删除容器，除非手动执行 docker rm 命令。我们这里只是进行简单的验证与查看结果，不需要排障和保留结果，因此使用 –rm 参数可以避免浪费空间。</p></li><li><p>ubuntu:16.04：这里指定镜像名称为 ubuntu:16.04。</p></li><li><p>/bin/bash：放在镜像名后面的命令，我们的目的是有个交互式的 Shell 来执行命令，因此用的是 bash。</p></li></ul><p>进入容器后，我们可以在 Shell 环境下操作，执行命令。这里我们执行了 <code>cat /etc/os-release</code>，从返回的结果看到容器内是 Ubuntu 16.04.5 LTS 系统。 最后我们通过 <code>exit</code> 退出了容器。</p><h2 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h2><p>通常情况下，我们需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面，我们举两个例子来说明一下：</p><p>首先，不使用 <code>-d</code> 参数来运行 nginx 容器：</p><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ docker container <span class="hljs-built_in">run</span> -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> <span class="hljs-comment">--name nginx nginx:1.14.2</span><br></code></pre></td></tr></table></figure><ul><li><p>-p：这里 -p 参数表示将容器内的端口映射至宿主机上。</p></li><li><p>–name: 指定容器的容器名称，如果不指定会随机分配一个。</p></li></ul><p>此时我们在浏览器中输入宿主机的 ip:port，比如我这里是 <a href="http://10.10.113.16/" target="_blank" rel="noopener">http://10.10.113.16/</a> ，容器就会把输出的结果（STOUT）打印到宿主机上面：</p><figure class="hljs highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ docker container run -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> --name nginx nginx:<span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">2</span><br><span class="hljs-number">10.10.22.162</span> - - <span class="hljs-string">[14/Feb/2019:02:27:54 +0000]</span> <span class="hljs-string">"<span class="hljs-keyword">GET</span> /favicon.ico HTTP/1.1"</span> <span class="hljs-number">404</span> <span class="hljs-number">571</span> <span class="hljs-string">"http://10.10.113.16/"</span> <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36"</span> <span class="hljs-string">"-"</span><br></code></pre></td></tr></table></figure><p>并且我们使用 <ctrl-c> 快捷键退出当前的输出流后，这个容器也会随之停止。</ctrl-c></p><p>然后，我们使用 <code>-d</code> 参数来运行 nginx 容器：</p><figure class="hljs highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">docker container <span class="hljs-built_in">run</span> -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> <span class="hljs-comment">--name nginx nginx:1.14.2</span><br><span class="hljs-number">660e2</span>ee880a74785582dbc4baac96c3a99a6e8300e02dcdc689c1e5d9fe0fe38<br></code></pre></td></tr></table></figure><p>使用 <code>-d</code> 参数启动后会返回一个唯一的容器 id。此时容器就在后台运行，我们依然可以通过浏览器访问 <a href="http://10.10.113.16/" target="_blank" rel="noopener">http://10.10.113.16/</a> 。</p><h2 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h2><p>我们在后台运行容器后，可以列出正在运行的容器。</p><p>列出容器的命令如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage:  docker container ls [OPTIONS]<br></code></pre></td></tr></table></figure><p>比如，我们列出刚才在后台运行的 Nginx 容器：</p><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ docker container ls<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES<br>660e2ee880a7        nginx:<span class="hljs-number">1.14</span><span class="hljs-meta">.2</span>        <span class="hljs-string">"nginx -g 'daemon of…"</span>   <span class="hljs-number">7</span> seconds ago       <span class="hljs-meta">Up</span> <span class="hljs-number">6</span> seconds        <span class="hljs-number">0.0</span><span class="hljs-meta">.0</span><span class="hljs-meta">.0</span>:<span class="hljs-number">80</span>-&gt;<span class="hljs-number">80</span>/tcp   nginx<br></code></pre></td></tr></table></figure><p>默认情况下，只会列出正在运行的容器。如果想列出所有的容器，包括已经停止的容器则需要添加 <code>-a</code> 参数。</p><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ docker container ls -a<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                NAMES<br>660e2ee880a7        nginx:<span class="hljs-number">1.14</span><span class="hljs-meta">.2</span>        <span class="hljs-string">"nginx -g 'daemon of…"</span>   <span class="hljs-number">58</span> seconds ago      <span class="hljs-meta">Up</span> <span class="hljs-number">57</span> seconds               <span class="hljs-number">0.0</span><span class="hljs-meta">.0</span><span class="hljs-meta">.0</span>:<span class="hljs-number">80</span>-&gt;<span class="hljs-number">80</span>/tcp   nginx<br>d9e0537848da        nginx:<span class="hljs-number">1.14</span><span class="hljs-meta">.2</span>        <span class="hljs-string">"nginx -g 'daemon of…"</span>   <span class="hljs-number">21</span> minutes ago      Exited (<span class="hljs-number">0</span>) <span class="hljs-number">20</span> minutes ago                        tender_villani<br></code></pre></td></tr></table></figure><h2 id="终止、启动与重启容器"><a href="#终止、启动与重启容器" class="headerlink" title="终止、启动与重启容器"></a>终止、启动与重启容器</h2><p>我们可以使用 <code>docker container stop</code> 命令来停止一个正在运行中的容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container stop nginx<br>nginx<br><br><span class="hljs-comment"># 此时可以看到 nginx 容器已经处于停止状态</span><br>docker container ls -a<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES<br>660e2ee880a7        nginx:1.14.2        <span class="hljs-string">"nginx -g 'daemon of…"</span>   20 minutes ago      Exited (0) 11 minutes ago                       nginx<br></code></pre></td></tr></table></figure><p>对于已停止的容器，我们可以使用 <code>docker container start</code> 命令来启动一个处于停止状态的容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container start nginx<br>nginx<br></code></pre></td></tr></table></figure><p>我们还可以用 <code>docker container restart</code> 命令来重启容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container restart nginx<br>nginx<br></code></pre></td></tr></table></figure><h2 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h2><p>对于后台运行的容器，我们可以通过 <code>docker container logs</code> 命令来查看正在运行容器的日志：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container logs nginx<br>10.10.22.162 - - [14/Feb/2019:03:06:39 +0000] <span class="hljs-string">"GET / HTTP/1.1"</span> 304 0 <span class="hljs-string">"-"</span> <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36"</span> <span class="hljs-string">"-"</span><br></code></pre></td></tr></table></figure><p>并且我们可以通过添加 <code>-f</code> 参数实时跟踪容器的日志：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container logs -f nginx<br>10.10.22.162 - - [14/Feb/2019:03:06:39 +0000] <span class="hljs-string">"GET / HTTP/1.1"</span> 304 0 <span class="hljs-string">"-"</span> <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36"</span> <span class="hljs-string">"-"</span><br>10.10.22.162 - - [14/Feb/2019:03:06:40 +0000] <span class="hljs-string">"GET / HTTP/1.1"</span> 304 0 <span class="hljs-string">"-"</span> <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36"</span> <span class="hljs-string">"-"</span><br></code></pre></td></tr></table></figure><p>这对于排查故障很有帮助。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>有多种进入容器的方式，这里我们只介绍 2 中方式：</p><ol><li><p>第一种，使用 <code>docker container attach</code> 进入容器。</p><p>这种方式表示将本地标准输入、输出、错误附加到正在运行的容器中。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container attach nginx<br></code></pre></td></tr></table></figure><p>这时，如果容器启动时执行的命令不是 bash 或者其他的 Shell 环境的话，是无法执行命令的，可以理解为把后台启动容器以前台的方式呈现。</p><p>这种方式进入容器后，使用 <ctrl-c> 快捷键退出输出流时，容器也会停止：</ctrl-c></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container attach nginx<br>^C<br>$ docker container ls -a<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES<br>660e2ee880a7        nginx:1.14.2        <span class="hljs-string">"nginx -g 'daemon of…"</span>   35 minutes ago      Exited (0) 41 seconds ago                       nginx<br></code></pre></td></tr></table></figure><p>因此不推荐使用这种方式来进入容器。</p></li><li><p>第二种，使用 <code>docker container exec</code> 在容器内执行命令来启动一个交互式的终端进入容器。</p><p>这种方式，相当于在容器内运行一个 bash 环境令并且添加参数 <code>-it</code> 来启动一个交互式的终端。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">exec</span> -ti nginx /bin/bash<br>root@1425410889aa:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>这样我们就可以在容器内执行命令了。比如我们修改主页的代码：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">exec</span> -ti nginx /bin/bash<br>root@1425410889aa:/<span class="hljs-comment"># cd /usr/share/nginx/html/</span><br>root@1425410889aa:/usr/share/nginx/html<span class="hljs-comment"># echo test &gt; index.html</span><br>root@1425410889aa:/usr/share/nginx/html<span class="hljs-comment"># exit</span><br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>此时执行 <code>exit</code> 退出容器后容器也不会停止，我们访问 nginx 会发现主页已经被修改：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://10.10.113.16<br><span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>这也是为什么推荐使用 <code>docker container exec</code> 的原因。</p></li></ol><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>我们可以使用 <code>docker container rm</code> 来删除一个已经处于停止状态下的容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container stop nginx<br>nginx<br><br>$ docker container rm nginx<br>nginx<br></code></pre></td></tr></table></figure><p>也可以添加 <code>-f</code> 参数来删除一个正在运行中的容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container ls<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES<br>b9f3e39cc713        nginx:1.14.2        <span class="hljs-string">"nginx -g 'daemon of…"</span>   33 seconds ago      Up 33 seconds       0.0.0.0:80-&gt;80/tcp   nginx<br><br>$ docker container rm -f nginx<br>nginx<br></code></pre></td></tr></table></figure><h2 id="根据容器的更改定制镜像"><a href="#根据容器的更改定制镜像" class="headerlink" title="根据容器的更改定制镜像"></a>根据容器的更改定制镜像</h2><p>镜像是容器的基础，每次执行 <code>docker container run</code> 时都会指定一个镜像作为容器运行的基础。</p><p>在之前的例子中，我们都是使用来自 Docker Hub 的官方镜像。直接使用这些镜像是可以满足一定的需求。但有时候无法直接满足需求时，我们就需要定制这些镜像。</p><p>我们依然运行一个 nginx 容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -d -p 80:80 --name nginx nginx:1.14.2<br></code></pre></td></tr></table></figure><p>然后进入 nginx 容器修改主页：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">exec</span> -ti nginx /bin/bash<br>root@b1d959eea100:/<span class="hljs-comment"># echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br></code></pre></td></tr></table></figure><p>现在刷新浏览器的话，会发现主页的内容发生变化：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://10.10.113.16<br>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker container diff</code> 命令看到具体的改动：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container diff nginx<br>C /usr<br>C /usr/share<br>C /usr/share/nginx<br>C /usr/share/nginx/html<br>C /usr/share/nginx/html/index.html<br>C /root<br>A /root/.bash_history<br>C /var<br>C /var/cache<br>C /var/cache/nginx<br>A /var/cache/nginx/client_temp<br>A /var/cache/nginx/fastcgi_temp<br>A /var/cache/nginx/proxy_temp<br>A /var/cache/nginx/scgi_temp<br>A /var/cache/nginx/uwsgi_temp<br>C /run<br>A /run/nginx.pid<br></code></pre></td></tr></table></figure><ul><li><p>A：文件或目录被添加</p></li><li><p>D：文件或目录被删除</p></li><li><p>C：文件或目录被修改</p></li></ul><p>现在我们定制好了容器的更改内容，接下来希望能将这个容器保存下来变成镜像以后可以直接使用。</p><p>当我们运行一个容器的时候（如果不使用共享数据卷），我们做任何文件的修改都会被记录于容器存储层，而 Docker 提供了一个 <code>docker container commit</code> 命令可以将容器的存储层保存下来成为镜像。即在原有的镜像基础上，再叠加上容器的存储层，并构成新的镜像。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker commit --author <span class="hljs-string">"Peng.Gao"</span> --message <span class="hljs-string">"修改默认首页"</span> nginx jugggao/nginx:1.0<br>sha256:62f1198899f38b566c0057b9448ae46666e73c013ad878c3de3ba56fed34ddf3<br></code></pre></td></tr></table></figure><p>我们还可以使用 <code>docker image history</code> 来查看镜像内的历史记录：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">history</span> jugggao/nginx:1.0<br>IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT<br>62f1198899f3        About a minute ago   nginx -g daemon off;                            92B                 修改默认首页<br>1293e2b0a1af        7 days ago           /bin/sh -c <span class="hljs-comment">#(nop)  CMD ["nginx" "-g" "daemon…   0B                  </span><br>&lt;missing&gt;           7 days ago           /bin/sh -c <span class="hljs-comment">#(nop)  STOPSIGNAL SIGTERM           0B                  </span><br>&lt;missing&gt;           7 days ago           /bin/sh -c <span class="hljs-comment">#(nop)  EXPOSE 80                    0B                  </span><br>&lt;missing&gt;           7 days ago           /bin/sh -c ln -sf /dev/stdout /var/<span class="hljs-built_in">log</span>/nginx…   22B                 <br>&lt;missing&gt;           7 days ago           /bin/sh -c <span class="hljs-built_in">set</span> -x  &amp;&amp; apt-get update  &amp;&amp; apt…   53.8MB              <br>&lt;missing&gt;           7 days ago           /bin/sh -c <span class="hljs-comment">#(nop)  ENV NJS_VERSION=1.14.2.0.…   0B                  </span><br>&lt;missing&gt;           7 days ago           /bin/sh -c <span class="hljs-comment">#(nop)  ENV NGINX_VERSION=1.14.2-…   0B                  </span><br>&lt;missing&gt;           7 days ago           /bin/sh -c <span class="hljs-comment">#(nop)  LABEL maintainer=NGINX Do…   0B                  </span><br>&lt;missing&gt;           8 days ago           /bin/sh -c <span class="hljs-comment">#(nop)  CMD ["bash"]                 0B                  </span><br>&lt;missing&gt;           8 days ago           /bin/sh -c <span class="hljs-comment">#(nop) ADD file:5a6d066ba71fb0a47…   55.3MB</span><br></code></pre></td></tr></table></figure><p>定制好新的镜像后，我们可以从这个镜像来运行容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container rm -f nginx<br>nginx<br><br>$ docker container run -d --name nginx -p 80:80 jugggao/nginx:1.0<br>2235f14c9bcd1ef448fb3f05add36f589a4bbf528b1305d5e2ca8e68cade6694<br></code></pre></td></tr></table></figure><p>现在查看主页默认就是我们已经修改完成后的主页了。</p><h2 id="上传镜像至私有仓库"><a href="#上传镜像至私有仓库" class="headerlink" title="上传镜像至私有仓库"></a>上传镜像至私有仓库</h2><p>如果我们想把定制好的镜像上传到我们的私有仓库里，以后再其他主机上也可以直接 Pull 下来使用。可以使用 <code>docker image push</code> 命令将镜像上传至私有仓库里。</p><p>首先我们需要在 Docker Hub 上注册账号，注册完成后，你的镜像名称里面的「用户名」字段必须和你注册的用户名相同。</p><p><img src="/images/DockerHub用户名.png" alt="Docker Hub 用户名"></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image ls <br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>jugggao/nginx       1.0                 62f1198899f3        17 minutes ago      109M<br></code></pre></td></tr></table></figure><p>然后登陆你的 Docker Hub：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker login<br>Login with your Docker ID to push and pull images from Docker Hub. If you don<span class="hljs-string">'t have a Docker ID, head over to https://hub.docker.com to create one.<br>Username: jugggao<br>Password: <br>WARNING! Your password will be stored unencrypted in /root/.docker/config.json.<br>Configure a credential helper to remove this warning. See<br>https://docs.docker.com/engine/reference/commandline/login/#credentials-store<br><br>Login Succeeded</span><br></code></pre></td></tr></table></figure><p>最后上传镜像至私有仓库：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker push jugggao/nginx:1.0<br>The push refers to repository [docker.io/jugggao/nginx]<br>d6bdc338e75e: Pushed <br>143b95aeb031: Mounted from library/nginx <br>dad66a2b02ef: Mounted from library/nginx <br>0a07e81f5da3: Mounted from library/nginx <br>1.0: digest: sha256:0ac52930ea9ff27072aa66b1a56bd62fa55269da0265994b3ba6425723c00b00 size: 1155<br></code></pre></td></tr></table></figure><p>现在我们可以在 Docker Hub 个人仓库中看到已经上传的 Docker 镜像。</p><p><img src="/images/Docker个人镜像.png" alt="Docker 个人镜像"></p><p>如果我们想在其他主机上使用，指定用户名来下载个人仓库中的镜像：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker pull jugggao/nginx:1.0<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们再来看下这个图：</p><p><img src="/images/Docker命令.png" alt="Docker 命令"></p><p>主要有以下内容：</p><ol><li><p>从 Docker Hub 上下载镜像至宿主机。</p></li><li><p>根据宿主机上的镜像来运行容器。 </p></li><li><p>根据容器的变化来提交成新的镜像。</p></li><li><p>将新的镜像上传至 Docker Hub。</p></li></ol><p>Docker 操作镜像的命令全部有：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image --<span class="hljs-built_in">help</span><br><br>Usage:  docker image COMMAND<br><br>Manage images<br><br>Commands:<br>  build       Build an image from a Dockerfile<br>  <span class="hljs-built_in">history</span>     Show the <span class="hljs-built_in">history</span> of an image<br>  import      Import the contents from a tarball to create a filesystem image<br>  inspect     Display detailed information on one or more images<br>  load        Load an image from a tar archive or STDIN<br>  ls          List images<br>  prune       Remove unused images<br>  pull        Pull an image or a repository from a registry<br>  push        Push an image or a repository to a registry<br>  rm          Remove one or more images<br>  save        Save one or more images to a tar archive (streamed to STDOUT by default)<br>  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE<br><br>Run <span class="hljs-string">'docker image COMMAND --help'</span> <span class="hljs-keyword">for</span> more information on a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure><p>Docker 操作容器的命令全部有：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container --<span class="hljs-built_in">help</span><br><br>Usage:  docker container COMMAND<br><br>Manage containers<br><br>Commands:<br>  attach      Attach <span class="hljs-built_in">local</span> standard input, output, and error streams to a running container<br>  commit      Create a new image from a container<span class="hljs-string">'s changes<br>  cp          Copy files/folders between a container and the local filesystem<br>  create      Create a new container<br>  diff        Inspect changes to files or directories on a container'</span>s filesystem<br>  <span class="hljs-built_in">exec</span>        Run a <span class="hljs-built_in">command</span> <span class="hljs-keyword">in</span> a running container<br>  <span class="hljs-built_in">export</span>      Export a container<span class="hljs-string">'s filesystem as a tar archive<br>  inspect     Display detailed information on one or more containers<br>  kill        Kill one or more running containers<br>  logs        Fetch the logs of a container<br>  ls          List containers<br>  pause       Pause all processes within one or more containers<br>  port        List port mappings or a specific mapping for the container<br>  prune       Remove all stopped containers<br>  rename      Rename a container<br>  restart     Restart one or more containers<br>  rm          Remove one or more containers<br>  run         Run a command in a new container<br>  start       Start one or more stopped containers<br>  stats       Display a live stream of container(s) resource usage statistics<br>  stop        Stop one or more running containers<br>  top         Display the running processes of a container<br>  unpause     Unpause all processes within one or more containers<br>  update      Update configuration of one or more containers<br>  wait        Block until one or more containers stop, then print their exit codes<br><br>Run '</span>docker container COMMAND --<span class="hljs-built_in">help</span><span class="hljs-string">' for more information on a command.</span><br></code></pre></td></tr></table></figure><p>如果你想知道某个命令的具体使用方法，可以进一步的查看帮助，比如：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container ls --<span class="hljs-built_in">help</span><br><br>Usage:  docker container ls [OPTIONS]<br><br>List containers<br><br>Aliases:<br>  ls, ps, list<br><br>Options:<br>  -a, --all             Show all containers (default shows just running)<br>  -f, --filter filter   Filter output based on conditions provided<br>      --format string   Pretty-print containers using a Go template<br>  -n, --last int        Show n last created containers (includes all states) (default -1)<br>  -l, --latest          Show the latest created container (includes all states)<br>      --no-trunc        Don<span class="hljs-string">'t truncate output<br>  -q, --quiet           Only display numeric IDs<br>  -s, --size            Display total file sizes</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
          <category> Dokcer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解镜像的构成</title>
      <link href="/2019/03/22/Docker/1.8%20Docker%20%E7%90%86%E8%A7%A3%E9%95%9C%E5%83%8F%E7%9A%84%E6%9E%84%E6%88%90/"/>
      <url>/2019/03/22/Docker/1.8%20Docker%20%E7%90%86%E8%A7%A3%E9%95%9C%E5%83%8F%E7%9A%84%E6%9E%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-8-理解镜像的构成"><a href="#1-8-理解镜像的构成" class="headerlink" title="1.8 理解镜像的构成"></a>1.8 理解镜像的构成</h1><p>对于开发者或者 Docker 维护者而言，经常需要根据我们的需求来定制镜像。所以我们会经常和镜像打交道。</p><p>之前我们使用过 <code>docker commit</code> 命令定制过属于自己的镜像。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。</p><p>在介绍 <code>Dockerfile</code> 之前，我们先来理解镜像是怎么构成的，理解了镜像的构成后再使用 <code>Dockerfile</code> 构建镜像就容易多了。</p><h2 id="Docker-镜像简介"><a href="#Docker-镜像简介" class="headerlink" title="Docker 镜像简介"></a>Docker 镜像简介</h2><p>Docker 镜像是一个只读的 Docker 容器模板，含有启动 Docker 容器所需的文件系统结构及其内容。</p><p>Docker 镜像的文件内容以及一些运行 Docker 容器的配置文件组成了 Docker 容器的静态文件系统运行环境：<strong>rootfs</strong>。</p><p>可以这么理解，Docker 镜像是 Docker 容器的静态视角，Docker 容器是 Docker 镜像的运行状态。</p><p>首先你需要明确以下两点：</p><ul><li><p>容器看起来像一个完整的操作系统就是因为镜像为容器提供了独立的文件系统，即 rootfs。</p></li><li><p>镜像是分层的，然后在使用联合挂载技术将这些镜像层组成一个完整的 rootfs，最后再使用联合挂载技术挂载一层可读写层，就形成了容器内我们所看见的统一的文件系统视图。</p></li></ul><h2 id="ROOTFS-文件系统"><a href="#ROOTFS-文件系统" class="headerlink" title="ROOTFS 文件系统"></a>ROOTFS 文件系统</h2><p>rootfs 是由镜像所提供的，是 Docker 容器在启动时内部进程可见的文件系统，即 Docker 容器的根目录。</p><p>rootfs 通常包含一个操作系统运行所需的文件系统，例如可能包含典型的类 Unix 操作系统中的目录系统，如 /dev、/proc、/bin、/etc、/lib、/usr、/tmp 以及运行 Docker 容器所需的配置文件、工具等。</p><p>rootfs 为只读模式。在挂载完毕之后，利用联合挂载（Union Mount）技术在已有的只读 rootfs 上再挂载一个读写层。这样，可读写层处于 Docker 容器文件系统的最顶层，其下可能联合挂载多个只读层，只有在 Docker 容器运行过程中文件系统发生变化时，才会把变化的文件内容写到可读写层，并<strong>隐藏</strong>只读层中的老版本文件。</p><blockquote><p><strong>注意</strong></p><p>我们之前在「1.3 Docker 数据卷的使用与挂载主机目录」中提过，容器内最上层的可读写层是临时的。这个临时的可读写层随着容器的重启或删除也会清空，所以不要在容器的可读写层保存持久化数据。通过数据卷或者挂载主机目录来保存持久化数据。</p></blockquote><p>我们用一张图来描述容器使用 rootfs 文件系统：</p><p><img src="/images/AUFS文件系统.png" alt="AUFS 文件系统"></p><p>我们来进行验证：</p><p>宿主机的进程（没有使用 Chroot 改变进程根目录）将会看到宿主机的文件系统，我们在宿主机运行一个 Java 程序：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nohup java -jar demo-0.0.1.jar &gt; /dev/null 2&gt;&amp;1  &amp;<br>[2] 23108<br><br><span class="hljs-comment"># 查看 java 进程的根目录</span><br>$ ls /proc/23108/root/<br>bin  boot  data  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br><br>$ du -sh --exclude=<span class="hljs-string">"/proc/23108/root/proc/*"</span> /proc/23108/root/<br>2.8G    /proc/23108/root/<br></code></pre></td></tr></table></figure><p>容器内的进程只能看到由镜像联合挂载的 rootfs 文件系统，我们在容器内运行一个 java 程序：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -d --name hello hello:0.1<br>1aa9628ae3d6cfa15aae907f7eeda4b77468725719d5b40e9aa5303a11181063<br><br>$ ps -ef | grep -v grep | grep java<br>root     28417 28399 31 00:09 ?        00:00:06 java -jar /demo-0.0.1.jar<br><br>$ ls /proc/28417/root/<br>bin  boot  demo-0.0.1.jar  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br><br>$ du -sh --exclude=<span class="hljs-string">"/proc/28417/root/proc/*"</span> /proc/28417/root/<br>291M    /proc/28417/root/<br></code></pre></td></tr></table></figure><p>可以发现容器内的整个文件系统要比宿主机的文件系统小的多。</p><p>我们用一幅图来比较运行在宿主机的进程与运行在容器内的进程：</p><p><img src="/images/DockerAUFS文件系统.png" alt="Docker AUFS 文件系统"></p><p>现在我们再来看官方的图应该就能理解宿主机的进程和容器内的进程的区别了，也应该能理解镜像到底是什么？就是给容器内的进程提供一个运行环境的：</p><p><img src="/images/宿主机进程和容器进程的区别.png" alt="宿主机进程和容器进程的区别"></p><p>这幅图右边的 Libraries 就是一个操作系统所需要的目录及文件，再把我们需要的程序放进去（比如说 Java 程序）。也就是我们刚才所说的 rootfs 文件系统，而这个 rootfs 操作系统就是由 Docker 镜像所提供的。</p><h2 id="Docker-镜像的分层"><a href="#Docker-镜像的分层" class="headerlink" title="Docker 镜像的分层"></a>Docker 镜像的分层</h2><p>Docker 镜像是采用分层方式构建的，每个镜像由一系列的「镜像层」构成。</p><p>Docker 镜像分层结构是 Docker 镜像轻量的主要原因。当需要修改容器镜像内的某个文件时，只对处于上方的读写层进行变动，不覆盖读写层下面已有的文件系统的内容，已有文件在只读层中的原始版本依然会存在，但会被隐藏。当你使用 <code>Docker commit</code> 或使用 <code>Dockerfile</code> 在原始镜像的基础上生成新的镜像时，保存的内容仅为最上层的读写层，相当于多了一个「镜像层」。</p><p>分层的目的就是为了在不同的镜像之间共享镜像层达到节省磁盘空间的目的。</p><p>我们用一张图来描述镜像的分层：</p><p><img src="/images/Docker镜像分层.png" alt="Docker 镜像分层"></p><p>我们来验证镜像的分层：</p><p>查看系统中的镜像：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image ls<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>wema/zuul           0.1                 7baa6ec0606d        2 days ago          338MB<br>wema/users          0.1                 0c6721ba85c8        2 days ago          337MB<br>wema/third-party    0.1                 4d112e570e6c        2 days ago          346MB<br>wema/teacher        0.1                 d96228e1ac53        2 days ago          336MB<br>wema/eureka         0.1                 4ff81306b255        2 days ago          324MB<br>wema/course         0.1                 ce2594635709        2 days ago          339MB<br>wema/company        0.1                 b01a31292858        2 days ago          336MB<br>tomcat              8                   168588387c68        13 days ago         463MB<br>mysql               5.7                 e47e309f72c8        2 weeks ago         372MB<br>java                8                   719e41f3e37b        3 months ago        280MB<br>redis               3                   87856cc39862        4 months ago        76MB<br></code></pre></td></tr></table></figure><p>由于 wema/zuul:0.1、wema/eureka:0.1 等这些封装了 Java 程序的镜像都是使用 java:8 这个镜像进行制作的，所以它们是共享了一些镜像层的：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">history</span> java:8<br>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT<br>719e41f3e37b        3 months ago        |0 /bin/sh -c yum install -y tar gzip &amp;&amp;    …   162MB               <br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  ENV JAVA_HOME=/usr/java/d…   0B                  </span><br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  MAINTAINER Aurelio Garcia…   0B                  </span><br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  CMD ["/bin/bash"]            0B                  </span><br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop) ADD file:455ccf156d2b27cef…   117MB               </span><br>&lt;missing&gt;           5 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  MAINTAINER Oracle Linux P…   0B </span><br><br><br>$ docker image <span class="hljs-built_in">history</span> wema/zuul:0.1<br>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT<br>7baa6ec0606d        2 days ago          /bin/sh -c <span class="hljs-comment">#(nop)  ENTRYPOINT ["java" "-jar"…   0B                  </span><br>1c5f0c7d9c6a        2 days ago          /bin/sh -c <span class="hljs-comment">#(nop) ADD file:53656c57d8b3ddca1…   58.3MB              </span><br>719e41f3e37b        3 months ago        |0 /bin/sh -c yum install -y tar gzip &amp;&amp;    …   162MB               <br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  ENV JAVA_HOME=/usr/java/d…   0B                  </span><br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  MAINTAINER Aurelio Garcia…   0B                  </span><br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  CMD ["/bin/bash"]            0B                  </span><br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop) ADD file:455ccf156d2b27cef…   117MB               </span><br>&lt;missing&gt;           5 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  MAINTAINER Oracle Linux P…   0B </span><br><br>$ docker image <span class="hljs-built_in">history</span> wema/eureka:0.1<br>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT<br>4ff81306b255        2 days ago          /bin/sh -c <span class="hljs-comment">#(nop)  ENTRYPOINT ["java" "-jar"…   0B                  </span><br>792aed369025        2 days ago          /bin/sh -c <span class="hljs-comment">#(nop) ADD file:cb8542050897d1ff9…   44.1MB              </span><br>719e41f3e37b        3 months ago        |0 /bin/sh -c yum install -y tar gzip &amp;&amp;    …   162MB               <br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  ENV JAVA_HOME=/usr/java/d…   0B                  </span><br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  MAINTAINER Aurelio Garcia…   0B                  </span><br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  CMD ["/bin/bash"]            0B                  </span><br>&lt;missing&gt;           3 months ago        /bin/sh -c <span class="hljs-comment">#(nop) ADD file:455ccf156d2b27cef…   117MB               </span><br>&lt;missing&gt;           5 months ago        /bin/sh -c <span class="hljs-comment">#(nop)  MAINTAINER Oracle Linux P…   0B</span><br></code></pre></td></tr></table></figure><p>可以看到  wema/zuul:0.1 和 wema/eureka:0.1 这两个镜像共享了 6 层镜像层。</p><p>所以 Docker 镜像并没有占用很大的空间：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker system df<br>TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE<br>Images              11                  10                  1.587GB             279.8MB (17%)<br>...<br></code></pre></td></tr></table></figure><p>现在你也应该能理解为什么当你在一个容器的读写层进行改变并生成新的镜像时，为什么不会覆盖下面已有的只读层，而是添加一层镜像层。因为其他镜像可能需要需要共享。</p><p>分层也能帮助我们更好的排查镜像制作中的错误。如果制作的镜像出了问题，我们只需要在出问题的前一层镜像的基础上重新制作即可。</p><p>现在再来看 Union FS（联合文件系统）与 Union Mount（联合挂载）技术。也容易理解多了：<strong>联合挂载就是用于将多个镜像层的文件系统挂载到一个挂载点来实现一个统一文件系统视图，形成联合文件系统。是下层存储驱动（如 Aufs、Overlay2）实现分层合并的方式</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是 Docker 镜像。这个文件系统更专业的名称为：rootfs（根文件系统）。</p></li><li><p>有了镜像提供 rootfs，Docker 只需要切换进程的根目录（Change Root，可以参考 Chroot 技术），然后再启动 Linux Namespace 隔离（包括进程隔离、挂载隔离、网络隔离、主机名隔离），设置指定的 Cgroup 限制参数。这样一个完成的容器就诞生了。</p></li><li><p>rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统的内核（bootfs 包含了 BootLoader 和 Kernel ），在Linux操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核。所以说，rootfs 只包括了操作系统的 「躯壳」，并没有包括操作系统的「灵魂」。</p></li><li><p>由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。所以容器才有了一个被反复宣传至今的重要特性：一致性。即无论在本地、云端，还是在一台任何地方的机器上，用户只需要解压打包好的容器镜像，那么这个应用运行所需要的完整的执行环境就被重现出来了。</p></li><li><p>Docker 镜像之所以轻量，是因为通常我们制作的镜像只满足容器内运行的程序所依赖的目录文件，并且内核是使用宿主机的内核。所以有很多官方镜像为了足够精简，下载的官方镜像通常少了很多常用的命令。如果需要的话就使用 <code>Dockerfile</code> 在官方的镜像的基础上再加工。</p></li><li><p>容器启动后，最上层的读写层只是临时的。如果不使用 <code>docker commit</code> 将容器进行提交为镜像，这个容器删除后，读写层随之被删除。</p></li><li><p>我们在来回顾一下第一章介绍的容器的实现，Docker 容器看起来像一个完整的操作系统主要是因为：rootfs 为容器提供了独立的根目录；Linux Pid Namespace（进程隔离）技术让容器内的进程拥有一个全新的进程空间；Linux Network Namespace（网络隔离）技术让容器拥有自己独立的网络栈、路由表、防火墙规则、Socket等；Linux hostname Namespace（主机名隔离）技术让容器拥有自己独立的主机名；Linux User Namespace（用户隔离）技术让容器拥有自己独立的用户；Linux Mount Namespace（挂载隔离）技术让容器拥有自己独立的挂载的设备，还有一些其他的技术这里就不进行介绍了。<strong>这些技术实际上修改了应用进程看待整个计算机的「视图」，即容器内进程的「视线」被操作系统做了限制，只能「看到」某些指定的内容。无论怎么「移花接木」，容器终究也只是进程而已</strong>。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://docs.docker.com/storage/storagedriver/" target="_blank" rel="noopener">Docker About storage drivers</a></p></li><li><p><a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">Docker Use the OverlayFS storage driver</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
          <category> Dokcer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 使用 Dockerfile 自制镜像</title>
      <link href="/2019/03/22/Docker/1.9%20Docker%20%E4%BD%BF%E7%94%A8%20Dockerfile%20%E8%87%AA%E5%88%B6%E9%95%9C%E5%83%8F/"/>
      <url>/2019/03/22/Docker/1.9%20Docker%20%E4%BD%BF%E7%94%A8%20Dockerfile%20%E8%87%AA%E5%88%B6%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-8-Docker-使用-Dockerfile-自制镜像"><a href="#1-8-Docker-使用-Dockerfile-自制镜像" class="headerlink" title="1.8 Docker 使用 Dockerfile 自制镜像"></a>1.8 Docker 使用 Dockerfile 自制镜像</h1><p>我们之前使用过 <code>docker commit</code> 来自制镜像，但为什么不要使用 <code>docker commit</code> 而是使用 Dockerfile 来自制进行呢？</p><p>首先，观察之前制作镜像时使用 <code>docker container diff</code> 命令输出的结果：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container diff nginx<br>C /usr<br>C /usr/share<br>C /usr/share/nginx<br>C /usr/share/nginx/html<br>C /usr/share/nginx/html/index.html<br>C /root<br>A /root/.bash_history<br>C /var<br>C /var/cache<br>C /var/cache/nginx<br>A /var/cache/nginx/client_temp<br>A /var/cache/nginx/fastcgi_temp<br>A /var/cache/nginx/proxy_temp<br>A /var/cache/nginx/scgi_temp<br>A /var/cache/nginx/uwsgi_temp<br>C /run<br>A /run/nginx.pid<br></code></pre></td></tr></table></figure><p>发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件除外，还有很多文件被添加或者修改了，比如说缓存文件、Pid 文件等等。这还只是最简单的操作，如果是安装软件包、编译构建，那会有大量无关的内容被添加进来，如果不注意清理，将会导致镜像很臃肿。</p><p>此外，使用 <code>docker commit</code> 自制镜像，意味着所有对镜像的操作都是黑箱操作：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">history</span> jugggao/nginx:1.0<br>IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT<br>62f1198899f3        About a minute ago   nginx -g daemon off;                            92B                 修改默认首页<br>...<br></code></pre></td></tr></table></figure><p>并不能看到实际执行的命令，这种镜像也被称为<strong>黑箱镜像</strong>。就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像（说不定还忘了），别人根本无从得知。所以维护黑箱镜像的工作是很痛苦的。</p><p>而且，之前介绍过镜像是分层存储的。除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p><p>所以，我们需要把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，期内包含了一条条<strong>指令</strong>，<strong>每一条指令构建一层镜像层</strong>，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>比如我们最多使用的自制镜像：</p><p>在一个空白目录，新建一个文本文件，名为 Dockerfile。Dockerfile 内容如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM jugggao/java:8-jre<br><br>COPY demo-0.0.1.jar /demo-0.0.1.jar<br><br>CMD [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"/demo-0.0.1.jar"</span>]<br></code></pre></td></tr></table></figure><p>然后我们就可以使用 <code>docker image build</code> 命令来构建镜像了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tree<br>.<br>├── demo-0.0.1.jar<br>└── Dockerfile<br><br>0 directories, 2 files<br><br>$ docker image build -t java-demo:0.1 .<br>Sending build context to Docker daemon  16.72MB<br>Step 1/3 : FROM jugggao/java:8-jre<br> ---&gt; 719e41f3e37b<br>Step 2/3 : ADD demo-0.0.1.jar /demo-0.0.1.jar<br> ---&gt; Using cache<br> ---&gt; 243662a30000<br>Step 3/3 : CMD [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"/demo-0.0.1.jar"</span>]<br> ---&gt; Using cache<br> ---&gt; 328d450440c1<br>Successfully built 328d450440c1<br>Successfully tagged java-demo:0.1<br></code></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共用到了 3 个指令：<code>FROM</code>、<code>COPY</code> 和 <code>CMD</code>。</p><p>我们接下来分别介绍 Dockerfile 的常用指令。</p><h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><p>所谓定制镜像，一定是以一个镜像为基础，在其上进行定制（添加镜像层）。</p><p>我们之前做容器健康检查时发现 Nginx 容器中没有 <code>curl</code> 命令，所需需要在其基础上添加 <code>curl</code> 工具：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> nginx:<span class="hljs-number">1.14</span>.<span class="hljs-number">2</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> apt-get update -y &amp;&amp; apt-get install -y curl</span><br></code></pre></td></tr></table></figure><p><code>FROM</code> 指令就是指定基础镜像，因此一个 Dockerfile 中 <code>FROM</code> 是必备的指令，并且必须是第一个。</p><p>在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 上有很多质量非常高的官方镜像：</p><ul><li><p>有可以直接拿来使用的服务类镜像：<a href="https://hub.docker.com/_/nginx" target="_blank" rel="noopener">Nginx</a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener">Tomcat</a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener">Php</a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener">Httpd</a>、<a href="https://hub.docker.com/_/wordpress" target="_blank" rel="noopener">Wordpress</a>、<a href="https://hub.docker.com/_/oracle-serverjre-8" target="_blank" rel="noopener">Server JRE</a>、<a href="https://hub.docker.com/_/mysql" target="_blank" rel="noopener">MySQL</a>、<a href="https://hub.docker.com/_/redis" target="_blank" rel="noopener">Redis</a>、<a href="https://hub.docker.com/_/mongo" target="_blank" rel="noopener">MongoDB</a> 等；</p></li><li><p>还有一些方便开发、构建、运行各种语言应用的镜像：<a href="https://hub.docker.com/_/node" target="_blank" rel="noopener">Node</a>、<a href="https://hub.docker.com/_/openjdk" target="_blank" rel="noopener">Openjdk</a>、<a href="https://hub.docker.com/_/python" target="_blank" rel="noopener">Python</a>、<a href="https://hub.docker.com/_/golang" target="_blank" rel="noopener">Golang</a>、<a href="https://hub.docker.com/_/ruby" target="_blank" rel="noopener">Ruby</a> 等；</p></li><li><p>如果没有找到对应的服务镜像，官方还提供了一些更为基础的操作系统镜像可以在其基础上自制专属的服务镜像：<a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener">Ubuntu</a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener">Debian</a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener">CentOS</a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener">Fedora</a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener">Alpine</a> 等。</p></li><li><p>甚至还有官方提供的空白镜像 <a href="https://hub.docker.com/_/scratch" target="_blank" rel="noopener">scratch</a>，这个镜像是虚拟的概念，它并不实际存在。如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来的所写的指令将作为镜像第一层开始存在。<br>对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的依赖库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p></li></ul><p>对于使用官方镜像，必须要阅读官方镜像的说明，或者直接阅读官方镜像的 Dockerfile 能有助于我们更好的使用官方镜像。</p><p>比如说 MySQL 官方镜像提供了一些变量可以方便我们配置 MySQL 的 Root 密码：</p><blockquote><p>MYSQL_ROOT_PASSWORD</p><p>This variable is mandatory and specifies the password that will be set for the MySQL root superuser account. In the above example, it was set to my-secret-pw.</p><p>…</p></blockquote><p>还告诉我们了 MySQL 数据存储的位置让我们能快速定位并使用数据卷或挂载数据目录：</p><blockquote><p>The -v /my/own/datadir:/var/lib/mysql part of the command mounts the /my/own/datadir directory from the underlying host system as /var/lib/mysql inside the container, where MySQL by default will write its data files.</p></blockquote><p>并且告诉我们如何使用自定义文件、如何备份数据库等等。</p><p>官方镜像之所以质量高，其一是因为官方镜像很精简；其二是因为官方镜像会考虑到各种各样的情况来制定逻辑关系。所以我们使用官方镜像时一定要阅读官方镜像的说明，避免重复造轮子。</p><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><p><code>RUN</code> 指令就是用来执行命令的。其格式有两种：</p><ul><li><p>Shell 格式：<code>RUN &lt;命令&gt; 参数 1 参数 2</code>，就像直接在命令行中输入的命令一样。我们制作镜像时通常会采用这种形式：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> nginx:<span class="hljs-number">1.14</span>.<span class="hljs-number">2</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> apt-get update -y &amp;&amp; apt-get install -y curl</span><br></code></pre></td></tr></table></figure></li><li><p>Exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数 1&quot;, &quot;参数 2&quot;]</code>，这更像是函数中调用的格式。</p></li></ul><p>我们现在就可以在 Dockerfile 使用 <code>RUN</code> 从一个基础的操作系统镜像来制作一个带有 Redis 服务的镜像了：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> debian:stretch<br><br><span class="hljs-keyword">RUN</span><span class="bash"> apt-get update</span><br><span class="hljs-keyword">RUN</span><span class="bash"> apt-get install -y gcc libc6-dev make wget</span><br><span class="hljs-keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="hljs-string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span></span><br><span class="hljs-keyword">RUN</span><span class="bash"> mkdir -p /usr/src/redis</span><br><span class="hljs-keyword">RUN</span><span class="bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="hljs-keyword">RUN</span><span class="bash"> make -C /usr/src/redis</span><br><span class="hljs-keyword">RUN</span><span class="bash"> make -C /usr/src/redis install</span><br></code></pre></td></tr></table></figure><p>这样制作出来的镜像是可以使用的，但是这种做法很不好。</p><p>我们之前提到过镜像是分层的，最开始也提到了 Dockerfile 中每一个指令都会建立一层镜像层。所以每个 <code>RUN</code> 指令都会新建立一层镜像层。上面的这种写法，创建了 7 层镜像层，这样做是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多刚开始写 Dockerfile 的人常犯的一个错误。</p><p>因此上面的 Dockerfile 正确的写法应该是这样：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> debian:stretch<br><br><span class="hljs-keyword">RUN</span><span class="bash"> buildDeps=<span class="hljs-string">'gcc libc6-dev make wget'</span> \<br>    &amp;&amp; apt-get update \<br><span class="hljs-comment"># 安装依赖包</span></span><br>    &amp;&amp; apt-get install -y $buildDeps \<br><span class="hljs-comment"># 下载 Redis 程序并进行解压编译安装</span><br>    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \<br>    &amp;&amp; mkdir -p /usr/src/redis \<br>    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=<span class="hljs-number">1</span> \<br>    &amp;&amp; make -C /usr/src/redis \<br>    &amp;&amp; make -C /usr/src/redis install \<br><span class="hljs-comment"># 安装完成后清理安装文件</span><br>    &amp;&amp; rm -rf /var/lib/apt/lists/* \<br>    &amp;&amp; rm redis.tar.gz \<br>    &amp;&amp; rm -r /usr/src/redis \<br>    &amp;&amp; apt-get purge -y --auto-remove $buildDeps<br></code></pre></td></tr></table></figure><p>Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令行换行方式，以及行首 <code>#</code> 进行注释的格式。 <code>&amp;&amp;</code> 表示前面的命令执行成功后才会执行后面的命令，可以将多个命令串联起来（<code>||</code> 是将多个命令并联起来，表示前面的命令执行失败才会执行后面的命令）。这样良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易。</p><p>这样做还有以下好处：</p><ol><li><p>首先，之前所有的命令只有一个目的：就是编译、安装 Redis 可执行文件。因为没有必要建立很多层，只需要一层就足够。因此仅仅使用一个 <code>RUN</code> 指令来完成这部分所有的任务，将之前的 7 层简化为了 1 层。</p></li><li><p>此外这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的删除的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。很多人刚开始写 Dockerfile 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p></li></ol><p>所以，我们在撰写 Dockerfile 的时候，要经常提醒自己，<strong>这并不是在写 Shell 脚本，而是在定义每一层该如何构建</strong>。</p><blockquote><p><strong>注</strong>：</p><p>在构建容器中如果有 <code>RUN</code> 指令，会生成一个中间容器，然后在中间容器执行相应的命令，运行完成后保存镜像生成中间镜像之后会移除中间容器。</p></blockquote><h2 id="COPY-复制文件或目录"><a href="#COPY-复制文件或目录" class="headerlink" title="COPY 复制文件或目录"></a>COPY 复制文件或目录</h2><p><code>COPY</code> 指令将从构建上下文目录中的文件或目录复制到新的一层镜像层内的目标位置。和 <code>RUN</code> 指令一样，也有两种格式：</p><ul><li><p>Shell 格式： <code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code>；</p></li><li><p>Exec 格式： <code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code>。</p></li></ul><p>比如我们之前制作的 Java Demo 镜像的 Dockerfile：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> jugggao/java:<span class="hljs-number">8</span>-jre<br><br><span class="hljs-keyword">COPY</span><span class="bash"> demo-0.0.1.jar /demo-0.0.1.jar</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"java"</span>, <span class="hljs-string">"-jar"</span>, <span class="hljs-string">"/demo-0.0.1.jar"</span>]</span><br></code></pre></td></tr></table></figure><p><strong>&lt;源路径&gt;</strong>可以是多个，甚至可以是通配符，其通配符规则要满足 Go 语言的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener">filepath.Match</a> 规则：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">COPY</span><span class="bash"> hom* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="bash"> hom?.txt /mydir/</span><br></code></pre></td></tr></table></figure><p><strong>&lt;目标路径&gt;</strong>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 参数来改变文件或目录的所属用户及所属组。</p><h2 id="ADD-复杂化的复制文件或目录"><a href="#ADD-复杂化的复制文件或目录" class="headerlink" title="ADD 复杂化的复制文件或目录"></a>ADD 复杂化的复制文件或目录</h2><p><code>ADD</code> 指令和 <code>COPY</code> 的格式基本一致：</p><ul><li><p>Shell 格式： <code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code>；</p></li><li><p>Exec 格式： <code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code>。</p></li></ul><p>只是 <code>ADD</code> 指令在 <code>COPY</code> 指令基础上增加了一些功能：</p><ul><li><p><strong>好用的功能</strong>：如果 <code>&lt;源路径&gt;</code> 为一个 tar 压缩文件的话，压缩格式为 <code>gzip</code>、<code>bzip2</code>以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这么压缩文件到 <code>&lt;目标路径&gt;</code> 中。某些情况下，这个自动解压缩的功能非常好用，比如说 <a href="https://github.com/CentOS/sig-cloud-instance-images/blob/a77b36c6c55559b0db5bf9e74e61d32ea709a179/docker/Dockerfile" target="_blank" rel="noopener">CentOS 官方镜像</a>：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM scratch<br>ADD centos-7-docker.tar.xz /<br>...<br></code></pre></td></tr></table></figure><p>如果你不希望解压压缩包，就不要在 <code>&lt;目标路径&gt;</code> 的结尾加上 <code>/</code>，这样 Docker 会把 <code>&lt;目标路径&gt;</code> 当做一个文件。</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> jugggao/java:<span class="hljs-number">8</span>-jre<br><br><span class="hljs-keyword">ADD</span><span class="bash"> demo-0.0.1.jar /demo-0.0.1.jar</span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"java"</span>, <span class="hljs-string">"-jar"</span>, <span class="hljs-string">"/demo-0.0.1.jar"</span>]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不好用的功能</strong>：如果 <code>&lt;源路径&gt;</code> 为一个 URL，Docker 引擎会试图下载这个 URL 连接的文件放到 <code>&lt;目标路径&gt;</code> 中。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，还需要增加额外的一层 <code>RUN</code> 进行权限调整；另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。<br>所以不如直接用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载、处理权限、解压缩，然后清理无用文件更合理。因此，这是个很不明确的功能，不推荐使用。</p></li></ul><p>总之，<strong>尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义非常明确，只是复制文件或目录而已。而 <code>ADD</code>，包含了更复杂的功能，其行为不是很清晰。所以，只有在需要自动解压缩的情况下去使用 <code>ADD</code> 指令</strong>。</p><h2 id="CMD-启动命令"><a href="#CMD-启动命令" class="headerlink" title="CMD 启动命令"></a>CMD 启动命令</h2><p><code>CMD</code> 指令有三种格式：</p><ul><li><p>Exec 格式：<code>CMD [&quot;可执行文件&quot;,&quot;参数 1&quot;, &quot;参数 2&quot;]</code>，首选格式。</p></li><li><p>Exec 参数格式: <code>CMD [&quot;参数 1&quot;, &quot;参数 2&quot;]</code>，这种格式作为 <code>ENTRYPOINT</code> 的默认参数。</p></li><li><p>Shell 格式： <code>CMD 命令 参数1 参数2</code>。</p></li></ul><p>我们反复说过，Docker 容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p><p><strong>第一种格式</strong>最为常见，也是官方推荐的使用格式。这类格式在解析时会被解析为 Json 数组，因此一定要使用双引号，而不要使用单引号。</p><p>我们来看 CentOS 7 的官方镜像的 Dockerfile:</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">ADD</span><span class="bash"> centos-7-docker.tar.xz /</span><br><br><span class="hljs-keyword">LABEL</span><span class="bash"> org.label-schema.schema-version=<span class="hljs-string">"1.0"</span> \<br>    org.label-schema.name=<span class="hljs-string">"CentOS Base Image"</span> \<br>    org.label-schema.vendor=<span class="hljs-string">"CentOS"</span> \<br>    org.label-schema.license=<span class="hljs-string">"GPLv2"</span> \<br>    org.label-schema.build-date=<span class="hljs-string">"20181205"</span></span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"/bin/bash"</span>]</span><br></code></pre></td></tr></table></figure><p>根据这个镜像启动的默认容器主进程是 <code>/bin/bash</code>，我们来进行验证：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it centos:7<br>  PID TTY          TIME CMD<br>    1 pts/0    00:00:00 bash<br></code></pre></td></tr></table></figure><p>所以我们默认启动 CentOS 容器会进入到一个可执行 Bash 环境下。</p><p>在运行容器的时候，可以指定新的命令来代替镜像中设置的这个默认命令，比如：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it centos:7 cat /etc/centos-release<br>CentOS Linux release 7.6.1810 (Core)<br></code></pre></td></tr></table></figure><p>我们用 <code>cat /etc/centos-release</code> 替换了默认的 <code>/bin/bash</code> 命令，输出了系统版本信息。</p><p><strong>第二种格式</strong>在某些情况下会使用到，比如说我们制作一些工具镜像。</p><p>我们来看之前制作过的 Stress 压测工具镜像：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> yum install -y epel-release &amp;&amp; yum install -y stress</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"/usr/bin/stress"</span>]</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"--help"</span>]</span><br></code></pre></td></tr></table></figure><p>这种方式 <code>CMD</code> 指令作为 <code>ENTRYPOINT</code> 指令的参数使用，我们默认启动这个容器时会提示帮助信息：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it stress:0.1<br>`stress<span class="hljs-string">' imposes certain types of compute stress on your system<br><br>Usage: stress [OPTION [ARG]] ...<br> -?, --help         show this help statement<br>     --version      show version statement<br> -v, --verbose      be verbose<br>...</span><br></code></pre></td></tr></table></figure><p>而且我们在运行这个容器时也可以指定参数来覆盖默认的 <code>--help</code> 参数。</p><p>我们制作 Java 镜像时也可以这样来指定运行的命令：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> jugggao/java:<span class="hljs-number">8</span>-jre<br><br><span class="hljs-keyword">COPY</span><span class="bash"> demo-0.0.1.jar /demo-0.0.1.jar</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"java"</span>]</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"-jar"</span>, <span class="hljs-string">"/demo-0.0.1.jar"</span>]</span><br></code></pre></td></tr></table></figure><p>这种写法不是很推荐，我们在讲 <code>ENTRYPOINT</code> 指令时会说明。</p><p><strong>第三种格式</strong>在某些情况下很好用，比如说在使用到环境变量时。</p><p>比如说我们制作一个 CentOS 的镜像的 Dockerfile 如下：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"echo"</span>,<span class="hljs-string">"<span class="hljs-variable">$HOME</span>"</span>]</span><br></code></pre></td></tr></table></figure><p>我们用这个镜像启动容器时的输出为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -it --rm centos:<span class="hljs-built_in">test</span><br><span class="hljs-variable">$HOME</span><br></code></pre></td></tr></table></figure><p>如果 Dockerfile 如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM centos:7<br><br>CMD <span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span><br></code></pre></td></tr></table></figure><p>这时就会得到我们期望的输出结果：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -it --rm centos:<span class="hljs-built_in">test</span><br>/root<br></code></pre></td></tr></table></figure><p>这是因为，如果使用 Shell 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数形式执行。</p><p>上面的例子中：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span></span><br></code></pre></td></tr></table></figure><p>在实际执行中，会将其更改为：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"sh"</span>, <span class="hljs-string">"-c"</span>, <span class="hljs-string">"echo <span class="hljs-variable">$HOME</span>"</span>]</span><br></code></pre></td></tr></table></figure><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>如果不想使用 Shell 格式但想进行一些依赖 Shell(输出变量等）的操作，记得加上 <code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;参数...&quot;]</code>。</p><p><strong>有一个初学者很容易出现的一个误区</strong>：在容器内使用 <code>Upstart</code> 或 <code>Systemd</code> 或直接以后台启动的形式去启动后台服务。</p><p>比如说：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> service nginx start</span><br></code></pre></td></tr></table></figure><p>或 </p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> systemctl start nginx</span><br></code></pre></td></tr></table></figure><p>或 </p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># Nginx 默认是以后台方式启动的</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"nginx"</span>]</span><br></code></pre></td></tr></table></figure><p>然后启动容器时执行命令后就立即退出了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Nginx 容器 FROM 的基础镜像为 Debian，Debian 系统使用 Upstart 来管理服务</span><br>$ docker container run --rm -it nginx:1.14.2 service nginx start<br></code></pre></td></tr></table></figure><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it nginx:1.14.2 nginx<br></code></pre></td></tr></table></figure><p>如果使用 <code>systemctl</code>，发现连命令都执行不了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 我自己用 CentOS 镜像做为基础镜像制作了一个 Nginx 镜像，CentOS 7 以上使用 Systemd 来管理服务</span><br>$ docker container run --rm -it nginx:<span class="hljs-built_in">test</span> systemctl start nginx<br>Failed to get D-Bus connection: Operation not permitted<br></code></pre></td></tr></table></figure><p>如果你使用了这种写法，是因为你还是没区分容器和虚拟机的差别。依旧在用传统虚拟机的角度去理解容器。</p><p>再说一遍，容器只是进程而已。<strong>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其子进程不是它所关心的东西</strong>。</p><blockquote><p><strong>容器进程管理</strong></p><p>容器的主进程就是容器内的 1 号进程（Pid 为 1），虽然在宿主机看来就是个普通进程（PPid 为 1），但在容器内却扮演着超级进程的角色。也就是说容器的主进程管理着容器内其他的所有进程，容器内其他的所有进程都是这个主进程的子进程。</p><p>如果你启动的容器内有多个进程但是主进程没有管理能力（发送或接受信号、回收僵尸进程等能力），这个容器的设计是失败的。</p><p>这也是为什么推荐一个容器一个进程(One Process Per Container)的原因。</p></blockquote><p>而使用了 <code>service nginx start</code> 命令，则是希望 Upstart 来以后台守护进程形式启动 Nginx 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh -c service nginx start</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就退出了，<code>sh -c service nginx start</code> 这个主进程自然也会退出。作为主进程退出了，自然就会令容器退出。</p><p>这也是为什么 <code>CMD</code> 指令不推荐使用 Shell 格式的原因，因为用户往往会忽略了 <code>sh -c</code> 这个补充的命令。</p><p>而使用了 Exec 格式直接执行 <code>nginx</code> 命令，执行完毕后会运行 Nginx 后台程序，执行的命令 <code>nginx</code> 也会退出，从而导致主进程退出，令容器也退出了。</p><p>所以正确的写法是：<strong>让容器的主进程始终保持前台运行，使程序一直执行</strong>：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"nginx"</span>, <span class="hljs-string">"-g"</span>, <span class="hljs-string">"daemon off;"</span>]</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"java"</span>, <span class="hljs-string">"-jar"</span>, <span class="hljs-string">"demo.jar"</span>]</span><br></code></pre></td></tr></table></figure><p>如何判断你的进程是否是前台运行：最好的标志就是你运行程序后输入回车不会退回到终端。</p><p>总之，<strong>就是一定要保证你的容器的启动命令一直执行，不会退回到终端</strong>。</p><p><strong>还有一种自作聪明的写法</strong>：添加类似于 <code>tail</code>、<code>top</code> 这种可以前台运行的程序保持持续输出，使你的主程序不会退出。网上有不少类似的写法，误导初学者。</p><p>比如说：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CMD service nginx start &amp;&amp; tail -f /var/<span class="hljs-built_in">log</span>/nginx/access.log<br></code></pre></td></tr></table></figure><p>使用了这种写法的确能达到在容器内后台启动进程而不退出的效果，我们来模拟这种写法：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 挂载这两个文件只是为了使用 ps 命令查看进程，Nginx 官方镜像中不带 ps 命令</span><br>$ docker container run -d \<br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,src=/usr/bin/ps,dst=/usr/bin/ps \<br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,src=/usr/lib64/libprocps.so.4,dst=/usr/lib/libprocps.so.4 \<br>    --name nginx \<br>    nginx:1.14.2 sh -c <span class="hljs-string">"service nginx start &amp;&amp; tail -f /var/log/nginx/access.log"</span><br></code></pre></td></tr></table></figure><p>我们查看容器的状态是正常的，容器的启动命令为 <code>sh -c &#39;service nginx start &amp;&amp; tail -f /var/log/nginx/access.log&#39;</code>：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container ls --no-trunc<br>...     <span class="hljs-built_in">command</span>     ...                                                         STATUS          PORTS       NAMES<br>...     <span class="hljs-string">"sh -c 'service nginx start &amp;&amp; tail -f /var/log/nginx/access.log'"</span>      Up 2 minute     80/tcp      nginx<br></code></pre></td></tr></table></figure><p>我们来查看容器的主进程（容器内 Pid 为 1）：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">exec</span> nginx ps -ef<br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         1     0  0 18:08 ?        00:00:00 sh -c service nginx start &amp;&amp; tail -f /var/<span class="hljs-built_in">log</span>/nginx/access.log<br>root        13     1  0 18:08 ?        00:00:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf<br>nginx       14    13  0 18:08 ?        00:00:00 nginx: worker process<br>root        15     1  0 18:08 ?        00:00:00 tail -f /var/<span class="hljs-built_in">log</span>/nginx/access.log<br>root        16     0  0 18:30 ?        00:00:00 ps -ef<br></code></pre></td></tr></table></figure><p>主进程依靠 <code>tail -f /var/log/nginx/acess.log</code> 一直在运行所以没有退出，所以容器没有退出。</p><p>这么做蠢在哪：Nginx 进程变成了「孤儿进程」，因为主进程没有管理子进程的能力。</p><blockquote><p><strong>孤儿进程与僵尸进程管理</strong></p><p>当一个子进程终止后，它首先会变成一个「失效（Defunct）」的进程，也称为「僵尸（zombie）」进程，等待父进程或系统收回（Reap）。在 Linux 内核中维护了关于「僵尸」进程的一组信息（PID，终止状态，资源使用信息），从而允许父进程能够获取有关子进程的信息。如果不能正确回收「僵尸」进程，那么他们的进程描述符仍然保存在系统中，系统资源会缓慢泄露。</p><p>大多数设计良好的多进程应用可以正确的收回僵尸子进程，比如 NGINX Master 进程可以收回已终止的 Worker 子进程。</p><p>如果父进程已经结束了，那些依然在运行中的子进程会成为「孤儿（Orphaned）」进程。</p></blockquote><p>我们来杀掉容器内的 Nginx 进程：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">exec</span> nginx sh -c <span class="hljs-string">"kill -9 13 14"</span><br><br>$ docker container ls<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES<br>b63b4e7b2d1d        nginx:1.14.2        <span class="hljs-string">"sh -c 'service ngin…"</span>   3 minutes ago       Up 3 minutes        80/tcp              nginx<br><br>$ docker container <span class="hljs-built_in">exec</span> nginx ps -ef<br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         1     0  0 18:50 ?        00:00:00 sh -c service nginx start &amp;&amp; tail -f /var/<span class="hljs-built_in">log</span>/nginx/access.log<br>root        15     1  0 18:50 ?        00:00:00 tail -f /var/<span class="hljs-built_in">log</span>/nginx/access.log<br>root        27     0  0 18:54 ?        00:00:00 ps -ef<br></code></pre></td></tr></table></figure><p>结束了 Nginx 进程后，容器状态正常，但是服务却不可用了。</p><p>即使可以使用健康检查机制可以判断容器内服务的状态，但是还是不推荐这么做，因为一个 Nginx 容器，它的主进程就应该是 Nginx 服务，Nginx 服务挂掉，容器就应该被关闭。</p><p>所以，我们还需要记住一点：<strong>一个容器的主进程不应该是  Shell 环境（比如说 <code>/bin/bash</code>、<code>/bin/sh</code>），如果你这么做，你就把容器当成虚拟机来使用了。容器内的主进程应该就是服务前台启动模式的进程，而不是依赖其他的进程保持看似一直运行中的「假象」。</strong></p><h2 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h2><p><code>ENTRYPOINT</code> 指令有两种格式，用法和 <code>CMD</code> 一样：</p><ul><li><p>Exec 格式：<code>CMD [&quot;可执行文件&quot;,&quot;参数 1&quot;, &quot;参数 2&quot;]</code>，首选格式。</p></li><li><p>Shell 格式： <code>CMD 命令 参数1 参数2</code>。</p></li></ul><p><code>ENTRYPOINT</code> 和 <code>CMD</code> 的功能一样，都是在指定容器启动的程序以及参数。<code>ENTRYPOINT</code> 在运行时也可以被替代，只是比 <code>CMD</code> 要麻烦一些，需要在 <code>docker container run</code> 命令后加上 <code>--entrypoint</code> 参数来覆盖默认的 <code>ENTRYPOINT</code> 指令。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令。即实际执行时，将变为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;ENTRYPOINT&gt; &lt;CMD&gt;<br></code></pre></td></tr></table></figure><p>比如我们之前制作过的 Stress 镜像：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> yum install -y epel-release &amp;&amp; yum install -y stress</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"/usr/bin/stress"</span>]</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"--help"</span>]</span><br></code></pre></td></tr></table></figure><p>通过这个镜像运行的 Stress 容器的默认主程序为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /usr/bin/stress --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 之后为什么还要有 <code>ENTRYPOINT</code>，我们来看以下两种场景。</p><p><strong>场景一：把镜像当做工具来使用</strong></p><p>我们如果有一些工具，比如说压测工具、监控工具或者调试工具等。不希望在容器中安装此工具，但希望有时又需要在容器内使用该工具，这时就可以制作一个工具镜像来使用。</p><p>我们用 <code>htop</code> 工具来举例：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> alpine:latest<br><br><span class="hljs-keyword">RUN</span><span class="bash"> apk add --update htop &amp;&amp; rm -rf /var/cache/apk/*</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"htop"</span>]</span><br><span class="hljs-keyword">CMD</span><span class="bash"> []</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image build -t htop:v1 .<br>...<br>Successfully built 7648edfce8b0<br>Successfully tagged htop:v1<br></code></pre></td></tr></table></figure><p>我们来运行这个工具镜像来监控 Nginx 容器内的进程：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --pid container:nginx  htop:v1<br></code></pre></td></tr></table></figure><ul><li><code>--pid</code> 用于配置容器的 Linux Pid Namespace，可选值有 <code>container:&lt;name|id&gt;</code>、<code>host</code>，前者为共享容器的进程空间，后者为共享宿主机的进程空间。</li></ul><p><img src="/images/Htop镜像使用一.png" alt="Htop 镜像使用一"></p><p>我们使用这个工具镜像启动一个运行 <code>htop</code> 命令的容器，并监控了 Nginx 容器内的进程。</p><p>我们在来使用这个工具镜像启动一个运行 <code>htop</code> 命令的容器，监控宿主机的进程：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --pid host htop:v1<br></code></pre></td></tr></table></figure><p><img src="/images/Htop镜像使用二.png" alt="Htop 镜像使用二"></p><p>我们还可以直接添加 <code>-t</code> 参数来显示进程树：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --pid container:nginx  htop:v1 -t<br></code></pre></td></tr></table></figure><p><img src="/images/Htop镜像使用三.png" alt="Htop 镜像使用三"></p><p>那么，为什么要使用 <code>ENTRYPOINT [&quot;htop&quot;]</code>，使用 <code>CMD [&quot;htop&quot;]</code> 不是也可以使用吗？</p><p>因为如果使用 <code>CMD [&quot;htop&quot;]</code> 就无法直接加参数使用命令：</p><p>我们来制作一个使用 <code>CMD</code> 指令的 Htop 镜像：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> alpine:latest<br><br><span class="hljs-keyword">RUN</span><span class="bash"> apk add --update htop &amp;&amp; rm -rf /var/cache/apk/*</span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"htop"</span>]</span><br></code></pre></td></tr></table></figure><p>然后添加 <code>-t</code> 参数：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --pid container:nginx  htop:v2 -t<br>docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused <span class="hljs-string">"exec: \"-t\": executable file not found in <span class="hljs-variable">$PATH</span>"</span>: unknown.<br></code></pre></td></tr></table></figure><p>因为 <code>-t</code> 会覆盖掉 <code>CMD</code> 指令中的 <code>htop</code> 命令，而 <code>-t</code> 不是命令，所以就会执行失败，找不到 <code>-t</code> 这个可执行文件。</p><p>如果我们希望加入 <code>-t</code> 参数，则必须输入完整的命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --pid container:nginx  htop:v2 htop -t<br></code></pre></td></tr></table></figure><p>显然，这不是很好的解决方案。没有使用 <code>ENTRYPOINT</code> 指令指定可执行文件与 <code>CMD</code> 指令指定参数结合使用来的方便。</p><p>这是第一种使用 <code>ENTRYPOINT</code> 指令效果很好的场景，类似的可以制作的工具镜像还有很多：Strace 工具镜像跟踪进程（需要共享 Pid Namespace）、Tcpdump 工具镜像进行抓包（需要共享 Network Namespace）、Xtrabackup 工具镜像对 MySQL 数据库进行备份（需要能够访问数据卷或共享的宿主机目录）等等。</p><p><strong>场景二：应用运行前的准备工作</strong></p><p>我们启动容器就是启动容器的主进程，有些时候，启动进程之前，需要做一些准备工作。</p><p>比如 MySQL 数据库，可能需要一些数据库配置、初始化的工作，这些工作必须在启动之前解决。</p><p>我们看 <a href="https://github.com/docker-library/mysql/blob/a7a737f1eb44db467c85c8229df9d886dd63460e/8.0/Dockerfile" target="_blank" rel="noopener">MySQL 官方镜像的 Dockerfile</a> 中的 <code>ENTRYPOINT</code> 指令：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile">...<br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"docker-entrypoint.sh"</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3306</span> <span class="hljs-number">33060</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"mysqld"</span>]</span><br>...<br></code></pre></td></tr></table></figure><p><code>ENTRYPOINT</code> 指令中的 <a href="https://github.com/docker-library/mysql/blob/a7a737f1eb44db467c85c8229df9d886dd63460e/8.0/docker-entrypoint.sh" target="_blank" rel="noopener"><code>docker-entrypoint.sh</code></a> 指令就是做一些准备工作：创建相关目录、根据指定的环境变量初始化 MySQL 密码、创建 MySQL 用户等。</p><p>这个脚本还有一个功能就是：根据 <code>CMD</code> 的内容来判断，如果为 MySQL 启动进程的话，就使用 <code>mysql</code> 用户进行启动 MySQL 进程，否则就是用 <code>root</code> 用户执行。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># allow the container to be started with `--user`</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> = <span class="hljs-string">'mysqld'</span> -a -z <span class="hljs-string">"<span class="hljs-variable">$wantHelp</span>"</span> -a <span class="hljs-string">"<span class="hljs-variable">$(id -u)</span>"</span> = <span class="hljs-string">'0'</span> ]; <span class="hljs-keyword">then</span><br>    _check_config <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span><br>    DATADIR=<span class="hljs-string">"<span class="hljs-variable">$(_get_config 'datadir' "$@")</span>"</span><br>    mkdir -p <span class="hljs-string">"<span class="hljs-variable">$DATADIR</span>"</span><br>    chown -R mysql:mysql <span class="hljs-string">"<span class="hljs-variable">$DATADIR</span>"</span><br>    <span class="hljs-built_in">exec</span> gosu mysql <span class="hljs-string">"<span class="hljs-variable">$BASH_SOURCE</span>"</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>因为 MySQL 初始化的工作以及我们在容器内执行其他命令可能都需要 <code>root</code> 权限，而运行 <code>mysqld</code> 进程需要使用 <code>mysql</code> 用户启动：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动一个 MySQL 容器</span><br>$ docker container run -d -e MYSQL_ROOT_PASSWORD=<span class="hljs-string">'123456'</span> --name mysql mysql:5.7<br>3cc01512aa6aee48a7e44eab038509be0d7f77eb8edfa8f615f18b1f423a741e<br><br><span class="hljs-comment"># 使用 busybox 工具镜像查看 MySQL 容器内的进程</span><br>$ docker container run --rm -it --pid container:mysql busybox ps -ef<br>PID   USER     TIME  COMMAND<br>    1 999       0:00 mysqld<br>  179 root      0:00 ps -ef<br><br><span class="hljs-comment"># UID 为 999 就是容器内的 mysql 用户</span><br>$ docker container <span class="hljs-built_in">exec</span> mysql cat /etc/passwd | grep 999<br>mysql:x:999:999::/home/mysql:<br></code></pre></td></tr></table></figure><p>我们运行其他的命令则使用的是 <code>root</code> 用户，这样方便我们调试、配置等：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">exec</span> mysql id<br>uid=0(root) gid=0(root) groups=0(root)<br></code></pre></td></tr></table></figure><p>使用 <code>ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</code> 来进行准备以及一些条件判断工作，可以更好的处理容器的进程以及调试工作。</p><p>同理 <a href="https://github.com/docker-library/redis/blob/7be79f51e29a009fefdc218c8479d340b8c4a5e1/5.0/Dockerfile" target="_blank" rel="noopener">Redis 官方镜像</a>中的 <a href="https://github.com/docker-library/redis/blob/7be79f51e29a009fefdc218c8479d340b8c4a5e1/5.0/docker-entrypoint.sh" target="_blank" rel="noopener"><code>docker-entrypoint.sh</code></a> 也是这么做的：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">...<br><span class="hljs-comment"># allow the container to be started with `--user`</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> = <span class="hljs-string">'redis-server'</span> -a <span class="hljs-string">"<span class="hljs-variable">$(id -u)</span>"</span> = <span class="hljs-string">'0'</span> ]; <span class="hljs-keyword">then</span><br>    find . \! -user redis -<span class="hljs-built_in">exec</span> chown redis <span class="hljs-string">'&#123;&#125;'</span> +<br>    <span class="hljs-built_in">exec</span> gosu redis <span class="hljs-string">"<span class="hljs-variable">$0</span>"</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">exec</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span><br></code></pre></td></tr></table></figure><p>该脚本的内容就是根据 <code>CMD</code> 指令的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务，否则依旧使用 <code>root</code> 身份执行。</p><p>所以<strong>如果在启动容器主进程之前需要做一些准备工作的话，将准备工作写到一个脚本中，然后在 <code>ENTRYPOINT</code> 指令中指定这个脚本，是一种比较合适的做法。</strong></p><p><strong>有一种不推荐的写法</strong>，我们之前在讲 <code>CMD</code> 指令时提到过一种不推荐的 <code>ENTRYPOINT</code> 指令和 <code>CMD</code> 指令一起用的情况：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> jugggao/java:<span class="hljs-number">8</span>-jre<br><br><span class="hljs-keyword">COPY</span><span class="bash"> demo-0.0.1.jar /demo-0.0.1.jar</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"java"</span>]</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"-jar"</span>, <span class="hljs-string">"/demo-0.0.1.jar"</span>]</span><br></code></pre></td></tr></table></figure><p>为什么不推荐这种写法，因为这种写法很不方便调试。</p><p>比如说我们希望启动一个带有 Java 程序的 Shell 环境的容器（如果只是为了测试、调试，可以把容器当做虚拟机使用）方便我们调试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it java:<span class="hljs-built_in">test</span> /bin/bash<br>Error: Could not find or load main class .bin.bash<br></code></pre></td></tr></table></figure><p>因为我们指定的入口点是 <code>java</code>，所以实际运行时执行的是 <code>java /bin/bash</code>，这当然启动不起来了。所以我们还需要使用 <code>--entrypoint</code> 参数覆盖默认的 <code>ENTRYPOINT</code> 指令的内容：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run --rm -it --entrypoint /bin/bash java:<span class="hljs-built_in">test</span> <br>bash-4.2<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>这么做显然很麻烦，所以这种情况并不适合使用 <code>ENTRYPOINT</code> 指令。</p><p><strong>总之，有以下情况适合使用 <code>ENTRYPOINT</code> 指令</strong>：</p><ul><li><p><strong><code>ENTRYPOINT</code> 应该在将容器当做一个可执行文件时定义，就是把容器当做一个命令来使用的时候使用它</strong>。</p></li><li><p><strong><code>ENTRYPOINT</code> 也可以用于在启动容器主进程之前执行事前准备脚本，用来辅助主进程的启动</strong>。</p></li></ul><blockquote><p><strong>注意</strong></p><p>还需要注意一点：如果你的 Dockerfile 中 <code>FROM</code> 的镜像中定义了 <code>CMD</code> 指令，是可以继承的。参考我之前给 Nginx 官网容器添加 <code>curl</code> 工具时并没有指定 <code>CMD</code> 指令。</p><p>但如果你又定义了 <code>ENTRYPOINT</code> 指令，那么 <code>FROM</code> 镜像中的 <code>CMD</code> 指令将会被清空。这种情况下，你的 Dockerfile 是无法继承 <code>FROM</code> 镜像中的 <code>CMD</code> 指令的，需要重新定义 <code>CMD</code>。</p></blockquote><h2 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h2><p><code>ENV</code> 指令有两种格式：</p><ul><li><p><code>ENV &lt;key&gt; &lt;value&gt;</code></p></li><li><p><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></p></li></ul><p><code>ENV</code> 指令用于设置环境变量，运行时的应用可以直接使用 Dockerfile 中 ENV 设置的环境变量。</p><p><code>ENV</code> 指令设置的环境变量还可以在 Dockerfile 中的以下指令中使用：</p><ul><li><code>ADD</code> </li><li><code>COPY</code></li><li><code>ENV</code></li><li><code>EXPOSE</code></li><li><code>FROM</code></li><li><code>LABEL</code></li><li><code>STOPSIGNAL</code></li><li><code>USER</code></li><li><code>VOLUME</code></li><li><code>WORKDIR</code></li><li><code>ONBUILD</code>（与上面的指令结合使用）</li></ul><p>比如，通常会在 <code>RUN</code> 中来使用我们设置的环境变量，我们来看 <a href="https://github.com/docker-library/mysql/blob/bb7ea52db4e12d3fb526450d22382d5cd8cd41ca/5.7/Dockerfile" target="_blank" rel="noopener">MySQL 官网镜像的 Dockerfile</a> 的用法：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile">...<br><span class="hljs-keyword">ENV</span> MYSQL_MAJOR <span class="hljs-number">8.0</span><br><span class="hljs-keyword">ENV</span> MYSQL_VERSION <span class="hljs-number">8.0</span>.<span class="hljs-number">15</span>-<span class="hljs-number">1</span>debian9<br><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"deb http://repo.mysql.com/apt/debian/ stretch mysql-<span class="hljs-variable">$&#123;MYSQL_MAJOR&#125;</span>"</span> &gt; /etc/apt/sources.list.d/mysql.list</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> &#123; \<br>    <span class="hljs-built_in">echo</span> mysql-community-server mysql-community-server/data-dir select <span class="hljs-string">''</span>; \<br>    <span class="hljs-built_in">echo</span> mysql-community-server mysql-community-server/root-pass password <span class="hljs-string">''</span>; \<br>    <span class="hljs-built_in">echo</span> mysql-community-server mysql-community-server/re-root-pass password <span class="hljs-string">''</span>; \<br>    <span class="hljs-built_in">echo</span> mysql-community-server mysql-community-server/remove-test-db select <span class="hljs-literal">false</span>; \<br>  &#125; | debconf-set-selections \<br>  &amp;&amp; apt-get update &amp;&amp; apt-get install -y mysql-community-client=<span class="hljs-string">"<span class="hljs-variable">$&#123;MYSQL_VERSION&#125;</span>"</span> mysql-community-server-core=<span class="hljs-string">"<span class="hljs-variable">$&#123;MYSQL_VERSION&#125;</span>"</span> &amp;&amp; rm -rf /var/lib/apt/lists/* \<br>  &amp;&amp; rm -rf /var/lib/mysql &amp;&amp; mkdir -p /var/lib/mysql /var/run/mysqld \<br>  &amp;&amp; chown -R mysql:mysql /var/lib/mysql /var/run/mysqld \<br>  &amp;&amp; chmod 777 /var/run/mysqld</span><br>...<br></code></pre></td></tr></table></figure><p>所以我们可以通过环境变量，我们可以让一个 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。</p><p>我们也可以在使用 <code>docker container run</code> 时指定 <code>-e &lt;key&gt;=&lt;value&gt;</code> 或 <code>--env &lt;key&gt;=&lt;value&gt;</code> 参数来覆盖 Dockerfile 中已经设置的环境变量。</p><h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><p><code>ARG</code> 指令的格式为： <code>ARG &lt;name&gt;[=&lt;default value&gt;]</code></p><p>构建参数和 <code>ENV</code> 效果一样，都是设置环境变量。不同的是，<code>ARG</code> 所设置的构建参数在以后容器运行时是不会存在这些环境变量的，也就是说 <code>ARG</code> 设置的环境变量只有在构建镜像的过程中可以使用。</p><blockquote><p>但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 可以查到此值的。</p></blockquote><p>此参数可以在 <code>docker image build</code> 构建镜像时使用 <code>--build-arg &lt;name&gt;=&lt;value&gt;</code> 参数来覆盖。</p><p><strong>如何选择 <code>ENV</code> 指令还是 <code>ARG</code> 指令</strong>：</p><p><strong>如果想保存为环境变量，就用 <code>ENV</code>，如果只是在 Dockerfile 中临时使用，就用 <code>ARG</code></strong>。</p><h2 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h2><p><code>VOLUME</code> 指令格式为为： <code>VOLUME &lt;path1&gt; &lt;path2&gt; ...</code></p><p>我们在理解镜像的构成时提到过，容器在运行时不要在最上层的可读写层中发生写操作，我们应该通过数据卷或者挂载主机目录来保存持久化数据。</p><p>为了防止用户运行容器时用户忘记将动态文件所保存目录挂载为卷，我们可以在 Dockerfile 中使用 <code>VOLUME</code> 指令事先指定某些目录挂载为匿名卷，这样即使用户不指定挂载，运行的应用也不会想容器最上层的可读写层写入数据。</p><p>我们看 <a href="https://github.com/docker-library/mysql/blob/bb7ea52db4e12d3fb526450d22382d5cd8cd41ca/5.7/Dockerfile" target="_blank" rel="noopener">MySQL 官方镜像的 Dockerfile</a> 的用法：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile">...<br><span class="hljs-keyword">VOLUME</span><span class="bash"> /var/lib/mysql</span><br>...<br></code></pre></td></tr></table></figure><p>这样在运行容器时，即使不通过 <code>docker container run -v</code> 或 <code>docker container run --mount</code> 来挂载容器内的 MySQL 数据目录，MySQL 产生的数据文件也不会写入到容器内最上层临时的可读写层：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -d -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:5.7<br>0b13690c0f106633c1dd7b3c5fe6ce2e432e6dbdfd58a4fd4c84cd690b0c074e<br><br>$ docker container inspect  -f <span class="hljs-string">"&#123;&#123; .Mounts | json &#125;&#125;"</span> mysql | jq<br>[<br>  &#123;<br>    <span class="hljs-string">"Type"</span>: <span class="hljs-string">"volume"</span>,<br>    <span class="hljs-string">"Name"</span>: <span class="hljs-string">"06960ef3d14bcf89e4559a87767d36395ff74b7ac86490b2f3bf59830dceaa72"</span>,<br>    <span class="hljs-string">"Source"</span>: <span class="hljs-string">"/var/lib/docker/volumes/06960ef3d14bcf89e4559a87767d36395ff74b7ac86490b2f3bf59830dceaa72/_data"</span>,<br>    <span class="hljs-string">"Destination"</span>: <span class="hljs-string">"/var/lib/mysql"</span>,<br>    <span class="hljs-string">"Driver"</span>: <span class="hljs-string">"local"</span>,<br>    <span class="hljs-string">"Mode"</span>: <span class="hljs-string">""</span>,<br>    <span class="hljs-string">"RW"</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">"Propagation"</span>: <span class="hljs-string">""</span><br>  &#125;<br>]<br><br>docker volume ls<br>DRIVER              VOLUME NAME<br><span class="hljs-built_in">local</span>               06960ef3d14bcf89e4559a87767d36395ff74b7ac86490b2f3bf59830dceaa72<br></code></pre></td></tr></table></figure><p>我们可以看到，定义了匿名卷之后，Docker 会生成一个 Volume，并把 <code>VOLUME</code> 指令所指定的路径自动挂载到这个 Volume 中。保证了任何向 MySQL 容器 <code>/var/lib/mysql</code> 目录中写入的数据都不会记录进容器内的可读写层，从而保证了容器存储层的无状态化。</p><p>当然，我们运行时可以覆盖这个匿名卷的挂载，比如：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container run -d -e MYSQL_ROOT_PASSWORD=123456 -v /data/mysql/data:/var/lib/mysql --name mysql mysql:5.7<br></code></pre></td></tr></table></figure><p>这样就把宿主机的 <code>/data/mysql/data</code> 目录挂载到了容器内的 <code>/var/lib/mysql</code> 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p><h2 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h2><p><code>EXPOSE</code> 指令的格式为：<code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code></p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口。这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。</p><p>在 Dockerfile 中写入这样的声明有两个好处：</p><ol><li><p>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；</p></li><li><p>在运行时使用随机端口映射时，也就是在使用 <code>docker container run -P</code> 运行容器时，会自动随机映射 <code>EXPOSE</code> 指令所指定的端口。</p></li></ol><p>与使用 <code>docker container run -p</code> 映射端口不通，<code>EXPOSE</code> 指令仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><p>但我们在编写 Dockerfile 时，最好还是声明容器内所使用的端口号以方便其他的使用者做端口映射。比如说开发者如果使用了 <code>EXPOSE</code> 指令声明自己写的程序所使用的端口号，那么运维人员不需要询问开发或者查看代码就可以将端口映射至宿主机了：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> jugggao/java:<span class="hljs-number">8</span>-jre<br><br><span class="hljs-keyword">COPY</span><span class="bash"> eureka-0.1.jar /eureka-0.1.jar</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">25001</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"java"</span>, <span class="hljs-string">"-jar"</span>, <span class="hljs-string">"/eureka-0.1.jar"</span>]</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tree<br>.<br>├── Dockerfile<br>└── eureka-0.1.jar<br><br>0 directories, 2 files<br><br>$ docker build -t eureka:0.1 .<br>...<br>Successfully tagged eureka:0.1<br><br>$  docker image inspect -f <span class="hljs-string">"&#123;&#123; .ContainerConfig.ExposedPorts | json &#125;&#125;"</span> eureka:0.1 | jq<br>&#123;<br>  <span class="hljs-string">"25001/tcp"</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就知道了这个镜像运行的进程所监听的端口号，方便我们做端口映射。</p><h2 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h2><p><code>WORKDIR</code> 指令的格式为：<code>WORKDIR &lt;path&gt;</code></p><p>使用 <code>WORKDIR</code> 指令可以指定工作目录（也可以成为当前目录）。指定完 <code>WORKDIR</code> 的工作目录之后，后续的指令以及运行的容器的当前目录就切换到工作目录。也就是说以后运行的命令就是在 <code>WORKDIR</code> 指定的工作目录中运行的。</p><p><code>WORKDIR</code> 指令的功能只是切换工作目录，因此这个目录必须存在。</p><p>我们的 Dockerfile 也可以这样写：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> nginx:<span class="hljs-number">1.14</span>.<span class="hljs-number">2</span><br><br><span class="hljs-keyword">COPY</span><span class="bash"> eureka-0.1.jar /eureka-0.1.jar</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/share/nginx/html</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> &gt; hello.html</span><br></code></pre></td></tr></table></figure><p>制作完这个镜像后启动一个伪终端默认也会进入到工作目录当中：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image build -t hello:<span class="hljs-built_in">test</span> .<br>...<br>Successfully tagged hello:<span class="hljs-built_in">test</span><br><br>$ docker container run -d -p 80:80 --name hello hello:<span class="hljs-built_in">test</span><br>4cb50a5c4a54a0d17b89b8a85abe66fbcb2db2f2f9c44f0ed28fc84ad721420f<br><br>$ docker container <span class="hljs-built_in">exec</span> -ti hello /bin/bash<br>root@4cb50a5c4a54:/usr/share/nginx/html<span class="hljs-comment"># ls</span><br>50x.html  hello.html  index.html<br></code></pre></td></tr></table></figure><p><strong>但是不要按照写脚本的惯性思维写成这个样</strong>：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> nginx:<span class="hljs-number">1.14</span>.<span class="hljs-number">2</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/share/nginx/html</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> &gt; hello.html</span><br></code></pre></td></tr></table></figure><p>我们来观察一下结果：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker build -t hello:<span class="hljs-built_in">test</span> .<br>Sending build context to Docker daemon  2.048kB<br>Step 1/3 : FROM nginx:1.14.2<br> ---&gt; 6fab4a5218dd<br>Step 2/3 : RUN <span class="hljs-built_in">cd</span> /usr/share/nginx/html<br> ---&gt; Running <span class="hljs-keyword">in</span> b38ebf018ef5<br>Removing intermediate container b38ebf018ef5<br> ---&gt; 16e6ca65bb65<br>Step 3/3 : RUN <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> &gt; hello.html<br> ---&gt; Running <span class="hljs-keyword">in</span> 187ff3fd6ea6<br>Removing intermediate container 187ff3fd6ea6<br> ---&gt; 9f717fbdebd3<br>Successfully built 9f717fbdebd3<br>Successfully tagged hello:<span class="hljs-built_in">test</span><br><br>$ docker run -d -p 80:80 --name hello hello:<span class="hljs-built_in">test</span><br>6f461a7923c31c679422b9e2f68b32500f65351d67415c9fb39c283a519eff00<br><br>$ docker <span class="hljs-built_in">exec</span> -ti hello /bin/bash<br>root@6f461a7923c3:/<span class="hljs-comment"># ls</span><br>bin  boot  dev  etc  hello.html  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br></code></pre></td></tr></table></figure><p>我们发现，<code>hello.html</code> 跑到容器内的「根」目录下了，没并没有受 <code>RUN cd /user/share/nginx/html</code> 这个指令的影响。</p><p>因为这样的写法是按照 Shell 脚本的方式来写。在 Shell 中，连续两行命令是同一个进程（bash 或 sh）执行环境，因此前一个命令修改的路径会保存在进程的内存状态中，会直接影响后一个命令。而在 Dockerfile 中，这两行 <code>RUN</code> 指令指定的命令的执行环境根本不同。</p><p>之前讲 <code>RUN</code> 指令的时候就提到过一个 <code>RUN</code> 指令就会产生一个中间容器，我们观察构建过程：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">Step 2/3 : RUN <span class="hljs-built_in">cd</span> /usr/share/nginx/html<br> ---&gt; Running <span class="hljs-keyword">in</span> b38ebf018ef5<br>Removing intermediate container b38ebf018ef5<br> ---&gt; 16e6ca65bb65<br><br>Step 3/3 : RUN <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello"</span> &gt; hello.html<br> ---&gt; Running <span class="hljs-keyword">in</span> 187ff3fd6ea6<br>Removing intermediate container 187ff3fd6ea6<br> ---&gt; 9f717fbdebd3<br></code></pre></td></tr></table></figure><p>所以这两行 <code>RUN</code> 指令指定的命令的执行环境是两个不同的中间容器，自然命令的执行环境也不同。</p><p>总之，<strong>如果需要改变工作目录或者当前目录的位置，应该使用 <code>WORKDIR</code> 指令，而不是执行 <code>cd</code> 命令</strong>。</p><h2 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h2><p><code>USER</code> 指令的格式为：<code>USER &lt;user&gt;[:&lt;group&gt;]</code></p><p><code>USER</code> 指令用于指定当前用户。与 <code>WORKDIR</code> 相似，都是改变环境状态并影响到以后的层，<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后的执行 <code>RUN</code>、<code>ENTRYPOINT</code>、<code>CMD</code> 这类命令的当前用户。</p><p><code>USER</code> 也只是切换用户，因此这个用户也必须提前存在。</p><p>比如我们以 CentOS 7 官方镜像为基础制作一个 Redis 服务镜像：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> yum install -y epel-release &amp;&amp; \<br>    yum install -y redis &amp;&amp; \<br>    groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><br><span class="hljs-keyword">USER</span> redis<br><br><span class="hljs-keyword">CMD</span><span class="bash"> [ <span class="hljs-string">"redis-server"</span> ]</span><br></code></pre></td></tr></table></figure><p>默认执行 <code>RUN</code>、<code>CMD</code> 等运行命令的指令默认用户是 root，使用 <code>USER</code> 指令在运行 Redis 进程之前切换下用户，容器的主进程 <code>redis-server</code> 的属主就是容器内的 redis 用户了。</p><blockquote><p><strong>提示</strong>：</p><p>如果你想使用 root 用户通过运行脚本，在脚本内切换用户启动服务，建议使用 <code>gosu</code>。不要使用 <code>su</code> 或 <code>sudo</code> 命令，因为这两个命令配置很麻烦，而且在 TTY 缺失的环境下经常无法使用。</p><p>可以参考 <a href="https://github.com/docker-library/redis/blob/7be79f51e29a009fefdc218c8479d340b8c4a5e1/5.0/Dockerfile" target="_blank" rel="noopener">Redis 官方镜像的 Dockerfile</a> 中使用 root 用户来执行启动脚本，并在<a href="https://github.com/docker-library/redis/blob/7be79f51e29a009fefdc218c8479d340b8c4a5e1/5.0/docker-entrypoint.sh" target="_blank" rel="noopener">启动脚本</a>中使用 <code>gosu</code> 来切换用户。</p></blockquote><h2 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h2><p><code>HEALTHCHECK</code> 指令有两种格式：</p><ul><li><p><code>HEALTHCHECK [OPTIONS] CMD command</code>：设置检查容器健康状况的命令</p></li><li><p><code>HEALTHCHECK NONE</code>：禁用从基础镜像继承的任何健康检查命令</p></li></ul><p>其中 <code>[OPTIONS]</code> 选项有：</p><ul><li><p><code>--interval=&lt;DURATION&gt;</code>：两次健康检查的间隔。默认为 30 秒</p></li><li><p><code>--timeout=&lt;DURATION&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败。默认 30 秒</p></li><li><p><code>--start-period=&lt;DURATION&gt;</code>：健康检查的初始化时间，容器启动后，在初始化时间之内健康检查失败不会计入重试次数。如果健康检查成功，则视为容器已经启动，此初始化时间失效。默认 0 秒</p></li><li><p><code>--retries=N</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>。默认 3 次</p></li></ul><p>和 <code>CMD</code> 指令、<code>ENTRYPOINT</code> 指令一样，<code>HEALTHCHECK</code> 指令只可以出现一次，如果写了多个，只有最后一个生效。</p><p>我们在「1.7 Docker 健康检查」讲过容器的健康检查，在 Dockerfile 中指定健康检查和 <code>docker container run --health-cmd</code> 类似：</p><figure class="hljs highlight Dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> jugggao/java:<span class="hljs-number">8</span>-jre<br><br><span class="hljs-keyword">ADD</span><span class="bash"> target/&lt;ServiceName&gt;-&lt;ServiceVersion&gt;.jar /&lt;ServiceName&gt;-&lt;ServiceVersion&gt;.jar</span><br><br><span class="hljs-keyword">HEALTHCHECK</span><span class="bash"> --interval=5s --timeout=3s \<br>  CMD curl -s http://localhost:&lt;ServicePort&gt;/health || <span class="hljs-built_in">exit</span> 1</span><br><br><span class="hljs-keyword">EXPOSE</span> &lt;ServicePort&gt;<br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"/&lt;ServiceName&gt;-&lt;ServiceVersion&gt;.jar"</span>]</span><br></code></pre></td></tr></table></figure><h2 id="LABEL-贴标签"><a href="#LABEL-贴标签" class="headerlink" title="LABEL 贴标签"></a>LABEL 贴标签</h2><p><code>LABEL</code> 指令的格式为：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p><p><code>LABEL</code> 指令将元数据添加到镜像中，</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>开发者主要使用的指令有：</p><ul><li><p><code>COPY</code> 指令进行文件的拷贝；</p></li><li><p><code>CMD</code> 指令容器启动的命令；</p></li><li><p><code>ENV</code> 配置一些环境变量，提供之后再构建过程中或容器运行时使用；</p></li><li><p><code>EXPOSE</code> 声明容器主进程所使用的端口号，方便他人理解；</p></li><li><p><code>VOLUME</code> 如果有持久化数据，一定要定义个匿名卷，防止不熟悉镜像的用户没有挂载容器内数据目录而造成数据丢失的情况。</p></li></ul><p>其他指令了解即可。</p><p>还有一些指令我这里没有介绍：<code></code>  </p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
          <category> Dokcer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus 安装配置和使用</title>
      <link href="/2019/03/22/Prometheus/install/"/>
      <url>/2019/03/22/Prometheus/install/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="二进制安装包方式"><a href="#二进制安装包方式" class="headerlink" title="二进制安装包方式"></a>二进制安装包方式</h3><p>二进制安装包方式非常简单，实验环境里推荐使用这种方式。首先下载安装包 prometheus-2.2.1.linux-amd64.tar.gz（实验楼提供的是 64 位 Linux 平台的安装包，其它平台可从 官网 下载），然后解压即可。<br><a id="more"></a><br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget http://labfile.oss.aliyuncs.com/courses/1102/prometheus-2.2.1.linux-amd64.tar.gz<br>$ tar xvfz prometheus-2.2.1.linux-amd64.tar.gz<br>$ <span class="hljs-built_in">cd</span> prometheus-2.2.1.linux-amd64<br>$ ./prometheus<br></code></pre></td></tr></table></figure></p><p>上面的命令会在默认的 9090 端口启动 Prometheus 服务，打开地址 <a href="http://localhost:9090/" target="_blank" rel="noopener">http://localhost:9090/</a> 即可看到其  Web 界面。</p><h3 id="源码方式"><a href="#源码方式" class="headerlink" title="源码方式"></a>源码方式</h3><p>Prometheus 是开源的， 因此可以下载源码到本地来编译安装。这种方式比较麻烦，适合想学习源码或做二次开发的人。感兴趣的同学可以自行研究，这里就不做讲解了。</p><h3 id="Docker-方式"><a href="#Docker-方式" class="headerlink" title="Docker 方式"></a>Docker 方式</h3><p>如果当前部署环境支持 Docker，那么可以采取 Docker 方式来运行 Prometheus 服务。使用下面的命令来启动一个 Prometheus 容器：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -p 9090:9090 prom/prometheus<br></code></pre></td></tr></table></figure><p>上面 把容器内的 9090 端口映射到了宿主机的 9090 端口，因此可以在宿主机上通过 <a href="http://localhost:9090/" target="_blank" rel="noopener">http://localhost:9090/</a> 来访问容器内的 Prometheus 服务。<br>Docker 的使用后面会有 一系列专门的实验来讲解，不熟悉的同学可以先跳过。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>执行 prometheus 命令的时候可以通过参数 –config.file 来指定配置文件路径， 默认 会使用同目录下的 prometheus.yml 文件。Prometheus 服务运行过程中如果配置文件有改动，可以给服务进程发送 SIGHUP 信号来通知服务进程重新从磁盘加载配置。这样无需重启，可以避免中断服务。</p><p>下面会逐一讲解 Prometheus 的核心配置，示例中用到的各种占位符包括：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">\&lt;boolean&gt;:  布尔值，<span class="hljs-literal">true</span> 或 <span class="hljs-literal">false</span><br>\&lt;duration&gt;: 持续时间，格式符合正则表达式 [0-9]+(ms|[smhdwy])<br>\&lt;labelname&gt;: 标签名，格式符合正则表达式 [a-zA-Z_][a-zA-Z0-9_]*<br>\&lt;labelvalue&gt;:  标签值，可以包含任意 unicode 字符<br>\&lt;filename&gt;: 文件名，任意有效的文件路径<br>\&lt;host&gt;: 主机，可以是主机名或 IP，后面可跟端口号<br>\&lt;path&gt;: URL 路径<br>\&lt;scheme&gt;: 协议，http 或 https<br>\&lt;string&gt;: 字符串<br>\&lt;secret&gt;: 密钥，比如密码<br>\&lt;tmpl_string&gt;: 模板字符串，里面包含需要展开的变量<br></code></pre></td></tr></table></figure><p>配置文件格式为 YAML，下面是一个配置文件示例：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">global:<br>  <span class="hljs-comment"># 抓取间隔，默认为 1m</span><br>  [ scrape_interval: &lt;duration&gt; | default = 1m ]<br><br>  <span class="hljs-comment"># 抓取超时时间，默认为 10s</span><br>  [ scrape_timeout: &lt;duration&gt; | default = 10s ]<br><br>  <span class="hljs-comment"># 规则评估间隔，默认为 1m</span><br>  [ evaluation_interval: &lt;duration&gt; | default = 1m ]<br><br><span class="hljs-comment"># 抓取配置</span><br>scrape_configs:<br>  [ - &lt;scrape_config&gt; ... ]<br><br><span class="hljs-comment">#  规则配置</span><br>rule_files:<br>  [ - &lt;filepath_glob&gt; ... ]<br><br><span class="hljs-comment"># 告警配置</span><br>alerting:<br>  alert_relabel_configs:<br>    [ - &lt;relabel_config&gt; ... ]<br>  alertmanagers:<br>    [ - &lt;alertmanager_config&gt; ... ]<br></code></pre></td></tr></table></figure></p><p><strong> global </strong><br>全局配置节点下的配置对所有其它节点都有效，同时也是其它节点的默认值。</p><p><strong> rule_files </strong><br>规则配置包含 记录规则配置和告警规则配置，节点下 只是列出文件，具体配置在各个文件中。<br>记录规则配置接下来会讲， 告警规则配置 在后面的告警实验中会讲解。</p><p><strong> alerting  </strong><br>告警配置 用于 Alertmanager，在告警实验中会讲解。</p><h3 id="抓取配置"><a href="#抓取配置" class="headerlink" title="抓取配置"></a>抓取配置</h3><p>抓取配置可以有多个，一般来说每个任务（Job）对应一个配置。单个抓取配置的格式如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 任务名</span><br>job_name: &lt;job_name&gt;<br><br><span class="hljs-comment"># 抓取间隔，默认为对应全局配置</span><br>[ scrape_interval: &lt;duration&gt; | default = &lt;global_config.scrape_interval&gt; ]<br><br><span class="hljs-comment"># 抓取超时时间，默认为对应全局配置</span><br>[ scrape_timeout: &lt;duration&gt; | default = &lt;global_config.scrape_timeout&gt; ]<br><br><span class="hljs-comment"># 协议，默认为 http，可选 https</span><br>[ scheme: &lt;scheme&gt; | default = http ]<br><br><span class="hljs-comment"># 抓取地址的 路径，默认为 /metrics</span><br>[ metrics_path: &lt;path&gt; | default = /metrics ]<br><br><span class="hljs-comment"># 抓取地址的参数</span><br>params:<br>  [ &lt;string&gt;: [&lt;string&gt;, ...] ]<br><br><span class="hljs-comment"># 是否尊重抓取回来的标签，默认为 false</span><br>[ honor_labels: &lt;boolean&gt; | default = <span class="hljs-literal">false</span> ]<br><br><span class="hljs-comment"># 静态目标配置</span><br>static_configs:<br>  [ - &lt;static_config&gt; ... ]<br><br><span class="hljs-comment"># 单次抓取的采样值个数限制，默认为 0，表示没有限制</span><br>[ sample_limit: &lt;int&gt; | default = 0 ]<br>honor_labels 表示是否尊重抓取回来的标签。当抓取回来的采样值的标签值跟服务端配置的不一致时，如果该配置为 <span class="hljs-literal">true</span>，则以抓取回来的为准。否则以服务端的为准，抓取回来的值会保存到一个新标签下，该新标签 名在原来的前面加上了“exported_”，比如 exported_job。<br><br>static_configs 下配置了该任务要抓取的所有实例，  按组 配置，包含相同标签的实例可以分为一组， 以简化配置。单个组的配置格式如下：<br><br><span class="hljs-comment">#  目标地址列表，地址由主机+端口 组成</span><br>targets:<br>  [ - <span class="hljs-string">'&lt;host&gt;'</span> ]<br><br><span class="hljs-comment"># 标签列表</span><br>labels:<br>  [ &lt;labelname&gt;: &lt;labelvalue&gt; ... ]<br></code></pre></td></tr></table></figure><p>抓取目标除了采用静态配置方式，还可以动态发现。动态发现依赖于一个服务发现服务（比如 Consul，可以从这个服务里查询到目前系统里的服务列表），适合监控 目标非常多并且经常变化的场景。 因为使用场景比较少，在以后需要的时候大家可以去进一步研究。</p><h3 id="记录规则配置"><a href="#记录规则配置" class="headerlink" title="记录规则配置"></a>记录规则配置</h3><p>记录规则允许我们把一些经常需要使用并且查询时计算量很大的查询表达式，预先计算并保存到一个新的时序。查询这个新的时序比 从原始一个或多个时序实时计算快得多，并且还能够避免不必要的计算。在一些特殊场景下这甚至是必须的，比如仪表盘里展示的各类定时刷新的数据，数据种类多且需要计算非常快。</p><p>记录规则配置文件的格式如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash">groups:<br>  [ - &lt;rule_group&gt; ]<br>记录规则配置按组来组织，一个组下的所有规则按顺序定时执行。单个组的格式如下：<br><br><span class="hljs-comment"># 组名，在文件内唯一</span><br>name: &lt;string&gt;<br><br><span class="hljs-comment"># 规则评估间隔，默认为对应的全局配置</span><br>[ interval: &lt;duration&gt; | default = global.evaluation_interval ]<br><br>rules:<br>  [ - &lt;rule&gt; ... ]<br>每个组下包含多条规则，格式如下：<br><br><span class="hljs-comment"># 规则名称，也就是该规则产生的时序数据的度量指标名</span><br>record: &lt;string&gt;<br><br><span class="hljs-comment"># PromQL 查询表达式，表示如何 得到采样值</span><br>expr: &lt;string&gt;<br><br><span class="hljs-comment"># 关联标签</span><br>labels:<br>  [ &lt;labelname&gt;: &lt;labelvalue&gt; ]<br>使用<br>学会安装和配置之后，接下来我们通过使用 Prometheus 监控其自身来学习 它的基本用法。<br><br>配置 Prometheus 监控其自身<br>Prometheus 服务本身也通过路径 /metrics 暴露了其内部的各项度量指标，我么只需要把它加入到监控目标里就可以。<br><br>global:<br>  <span class="hljs-comment"># 全局默认抓取间隔</span><br>  scrape_interval: 15s<br><br>scrape_configs:<br>  <span class="hljs-comment"># 任务名</span><br>  - job_name: <span class="hljs-string">'prometheus'</span><br><br>    <span class="hljs-comment">#  本任务的抓取间隔，覆盖全局配置</span><br>    scrape_interval: 5s<br><br>    static_configs:<br>      <span class="hljs-comment"># 抓取地址同  Prometheus 服务地址，路径为默认的 /metrics</span><br>      - targets: [<span class="hljs-string">'localhost:9090'</span>]<br>配置完成后启动服务：<br>$ ./prometheus<br></code></pre></td></tr></table></figure><p>可打开地址 <a href="http://localhost:9090/metrics" target="_blank" rel="noopener">http://localhost:9090/metrics</a> 来确认是否有抓取到数据。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 监控 </category>
          
          <category> Prometheus </category>
          
          <category> 安装 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker 简介与安装</title>
      <link href="/2019/03/22/Docker/1.1%20Docker%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
      <url>/2019/03/22/Docker/1.1%20Docker%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-Docker-简介与安装"><a href="#1-1-Docker-简介与安装" class="headerlink" title="1.1 Docker 简介与安装"></a>1.1 Docker 简介与安装</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Docker 容器其实就是一种特殊的进程</strong>。</p><p>其实 Docker 容器只是使用了 Linux 内核的一些技术：</p><ul><li><p><a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">Namespace</a> 技术对进程进行隔离；</p></li><li><p><a href="https://coolshell.cn/articles/17049.html" target="_blank" rel="noopener">Cgroups</a> 技术对进程进行资源限制；</p></li><li><p><a href="https://coolshell.cn/articles/17061.html" target="_blank" rel="noopener">Union FS</a>（目前 Docker 主要使用 Overlay2，不过 Overlay 与 AUFS 差别不是很大，可以先了解一下 AUFS）技术为进程构建出一个完善的文件系统。</p></li></ul><p>这样这个进程看起来就像是独立的操作系统了，这也是为什么很多人会把 Docker 项目称为「轻量级」虚拟化技术的原因，实际上是把虚拟机的概念套在了容器上。</p><p>不过我一直很排斥将 Docker 视为轻量级虚拟机技术的说法。如果把容器当做虚拟机使用的话，要进入容器进行调试该怎么办？ SSH 要怎么配置？ 一个容器里面是否应该启动多个进程？是否需要备份容器？这些问题都不好处理。如果把容器当做虚拟机使用，不建议使用 Docker 技术，而是直接去使用虚拟机来运行你的服务。</p><p>所以我们要正确使用 Docker，就要建立起<strong>容器化思维</strong>。要意识到容器的本质其实就是一个进程。当理解了容器实际上是一个进程以后：</p><ul><li><p>我们就不需要去备份容器了，而是应该把需要备份的数据放在容器外进行备份；</p></li><li><p>我们也不应该去在容器里启动多个进程了（可以，但没必要，除非特殊需要），因为容器本身就是一个单进程模型；</p></li><li><p>我们更不应该使用 SSH 的方式来进入容器了，只需要给容器并分配一个伪终端（必须说 bash 子进程、sh 子进程）即可。</p></li></ul><p>所以 Docker 容器和虚拟机完全不同，在运行 Docker 时，并没有一个真正的「Docker 容器」运行在宿主机上面。 Docker 帮你启动的，还是原来的应用进程，只不过创建这些进程时，Docker 为它们加上了各种各样的隔离与限制，这样使用 Docker 运行的进程就仿佛运行在一个一个「容器」里面，与世隔绝。 其实只不过都是「障眼法」罢了。</p><p>下面是官方给出的 Docker 与传统虚拟机的对比图：</p><p><img src="/images/Docker与传统虚拟机对比.png" alt="Docker 与传统虚拟机对比.png"></p><p>这幅图的左边为虚拟机的工作原理。其中 Hypervisor 的软件是虚拟机最主要的部分。它通过硬件<a href="https://www.redhat.com/zh/topics/virtualization/what-is-virtualization" target="_blank" rel="noopener">虚拟化</a>功能，模拟出了运行一个操作系统所需要的各种硬件，比如 CPU、内存、I/O 设备等等。然后，它在这些虚拟的硬件上安装了一个新的操作系统，即 Guest OS。</p><p>而这幅图的右边，则用了一个 Docker Engine 的软件替换了 Hypervisor，属于<a href="https://en.wikipedia.org/wiki/Container_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>,因为上层只是与系统其它部分隔离开的一系列进程，所以叫做<a href="https://www.redhat.com/zh/topics/containers/whats-a-linux-container" target="_blank" rel="noopener">容器</a>。</p><h2 id="Docker-的优势"><a href="#Docker-的优势" class="headerlink" title="Docker 的优势"></a>Docker 的优势</h2><ul><li><p><strong>更高效的利用系统资源</strong>。<br>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。</p></li><li><p><strong>更快速的启动时间</strong>。<br>启动一个虚拟机需要数分钟，而 Docker 容器应用由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级启动。</p></li><li><p><strong>一致的运行环境</strong>。<br>开发过程中一个常见的问题就是环境一致性的问题。由于开发环境、测试环境、生产环境不一致，导致有些 Bug 并未在开发过程中发现。而 Docker 的镜像提供了除内核外完整的运行时环境（上面提到的 Union FS 文件系统），确保了应用运行环境一致行。</p></li><li><p><strong>更轻松的迁移</strong>。<br>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行：物理机、虚拟机、公有云、私有云、甚至是个人电脑（Windows 系统或 MAC OS），其运行结果是一致的。因此用户可以很轻易的将一个平台上运行的容器迁移到另一个平台上。</p></li><li><p><strong>持续交付和部署</strong>。<br>对开发和运维（DevOps）人员来说，最希望的就是一次创建和配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合持续集成（CI）系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，还能结合持续部署（CD）系统进行自动部署。而且开发人员使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件。</p></li></ul><h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><p>前往 <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">Docker 官方文档</a>，选择适合的平台安装即可。</p><p>比如这里我将在 CentOS 与 Windows 平台上安装 Docker。</p><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p>这里使用的系统版本为 CentOS 7.6。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ uname -r<br>3.10.0-957.el7.x86_64<br><br>$ cat /etc/centos-release<br>CentOS Linux release 7.6.1810 (Core)<br></code></pre></td></tr></table></figure><p>有三种安装方式：</p><ul><li><p>配置 Docker Yum 源安装</p></li><li><p>手动下载 RPM 软件包安装</p></li><li><p>使用 Docker 官方脚本安装</p></li></ul><p>这里使用 Docker Yum 源进行安装。</p><ol><li><p>安装依赖包</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure></li><li><p>配置 Docker Yum 源</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure></li><li><p>安装 Docker CE</p><ul><li><p>安装最新版本的 Docker CE：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum install -y docker-ce docker-ce-cli containerd.io<br><br>$ docker --version<br>Docker version 18.09.2, build 6247962<br></code></pre></td></tr></table></figure></li><li><p>安装指定版本的 Docker CE：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum list docker-ce --showduplicates | sort -r<br>docker-ce.x86_64     3:18.09.2-3.el7                           docker-ce-test   <br>docker-ce.x86_64     3:18.09.2-3.el7                           docker-ce-stable <br>docker-ce.x86_64     3:18.09.2-3.el7                           @docker-ce-stable<br>docker-ce.x86_64     3:18.09.1-3.el7                           docker-ce-test   <br>docker-ce.x86_64     3:18.09.1-3.el7                           docker-ce-stable <br>docker-ce.x86_64     3:18.09.1-2.1.rc1.el7                     docker-ce-test   <br>docker-ce.x86_64     3:18.09.1-1.2.beta2.el7                   docker-ce-test   <br>docker-ce.x86_64     3:18.09.1-1.1.beta1.el7                   docker-ce-test   <br>docker-ce.x86_64     3:18.09.0-3.el7                           docker-ce-test   <br>docker-ce.x86_64     3:18.09.0-3.el7                           docker-ce-stable<br>...<br><br>$ yum install -y docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.io<br></code></pre></td></tr></table></figure></li></ul></li><li><p>启动 Docker</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl <span class="hljs-built_in">enable</span> --now docker.service<br><br>$ docker info<br>Containers: 0<br> Running: 0<br> Paused: 0<br> Stopped: 0<br>Images: 0<br>Server Version: 18.09.2<br>Storage Driver: overlay2<br> Backing Filesystem: xfs<br>...<br></code></pre></td></tr></table></figure></li></ol><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>开发人员想在自己的电脑上使用 Docker 方便开发测试使用，可以直接在 Windows 系统上安装 Docker。</p><p>安装 Docker 的 Windows 系统要求：</p><ul><li><p>Windows 10 64 位：Pro、Enterprise 或 Education（1607 版本，Build 14393 或更高版本）；</p></li><li><p>在 BIOS 中启用虚拟化；</p></li><li><p>具有 CPU SLAT 功能；</p></li><li><p>至少 4 GB 内存。</p></li></ul><p>这里使用的是 Windows Pro 1803 版本。</p><p><img src="/images/Windows版本.png" alt="Windows 版本"></p><p>安装 Docker：</p><ol><li><p>下载适用于 Windows 的 <a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener">Docker Desktop</a>。</p></li><li><p>双击 Docker for Windows Installer.exe 运行安装程序。</p></li><li><p>安装完成后启动 Docker Desktop。</p><p><img src="/images/DockerDesktop.png" alt="Docker Desktop"></p></li><li><p>运行 Powershell 检测是否安装完成。</p><p><img src="/images/Powershell检测Docker.png" alt="Powershell 检测 Docker"></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>首先记住，容器的本质只是一个进程。要用看待进程的方式来看待一个容器，而不是用看待虚拟机的方式来看待容器。</p></li><li><p>是否要用 Docker 也要考虑你的应用代码是否面对经常的变更与解耦，可以参考现在流行的微服务。对于半年、一年或许才更新一次的应用来说，用虚拟机或者物理机部署会更加合适。</p></li><li><p>Docker 项目其实并没有很复杂的技术实现，依赖的还是 Linux 底层技术，比如 Linux Namaspace 技术、Linux Cgroups 技术、以及类 Rootfs 技术实现的联合文件系统（Union FS）。有兴趣可以查阅这些 Linux 底层技术的资料。</p></li><li><p>其实容器本身是没有价值的，有价值的是「容器编排与调度」，比如说 Docker Swarm 、Kubernetes、Mesos 等。容器技术生态爆发的关于「容器编排」的战争，最终以 Kubernetes 项目和 CNCF 社区的胜利而告终。为什么 Docker 公司在这场战争中占据了很有利的先天条件（Docker 项目）还败给了 Google 公司推出的 Kubernetes，以后我会介绍这两种编排调度系统。有兴趣的话也可以在网上查阅一下有关于<a href="https://zhuanlan.zhihu.com/p/35951990" target="_blank" rel="noopener">容器编排战争</a>的资料。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://www.redhat.com/zh/topics/containers/whats-a-linux-container" target="_blank" rel="noopener">什么是 Linux 容器？</a></p></li><li><p><a href="https://www.redhat.com/zh/topics/virtualization/what-is-virtualization" target="_blank" rel="noopener">何为虚拟化？</a></p></li><li><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">Get Docker CE for CentOS</a></p></li><li><p><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Install Docker Desktop for Windows</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 容器 </category>
          
          <category> Dokcer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus 介绍</title>
      <link href="/2019/03/22/Prometheus/recommend/"/>
      <url>/2019/03/22/Prometheus/recommend/</url>
      
        <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Prometheus（简称 Prom） 是新一代的监控系统，配置简单却灵活，对容器、微服务等支持良好。本次实验我们先来了解一下 Prometheus 的基础概念。</p><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>Prometheus总览</li><li>Prometheus核心概念<a id="more"></a></li></ol><hr><h2 id="Prometheus总览"><a href="#Prometheus总览" class="headerlink" title="Prometheus总览"></a>Prometheus总览</h2><hr><p>Prometheus 是一个开源监控系统，它前身是 SoundCloud 的告警工具包。从 2012 年开始，许多公司和组织开始使用 Prometheus。该项目的开发人员和用户社区非常活跃，越来越多的开发人员和用户参与到该项目中。目前它是一个独立的开源项目，且不依赖于任何公司。为了强调这点和明确该项目治理结构，Prometheus 在 2016 年继Kurberntes 之后，加入了 Cloud Native Computing Foundation。</p><hr><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><hr><ul><li>多维度数据模型</li><li>灵活的查询语言</li><li>不依赖任何分布式存储</li><li>常见方式是通过拉取方式采集数据</li><li>也可通过中间网关支持推送方式采集数据</li><li>通过服务发现或者静态配置来发现监控目标</li><li>支持多种图形界面展示方式</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><hr><p>下面这张图描述了 Prometheus 的整体架构，以及其生态中的一些常用组件。</p><p><img src="/images/wm.png" alt></p><p>Prometheus Server  采用拉取方式从监控目标直接拉取数据，或者通过中间网关间接地拉取监控目标推送给 网关的数据。它在本地存储抓取的数据，通过一定规则进行清理和整理数据，然后把得到的结果存储起来。各种 Web UI 使用 PromQL 查询语言来从 Server 里获取数据。当 Server 监测到有异常时会推送告警给 Alertmanager， Alertmanager 负责去通知相关人。</p><h2 id="Prometheus-核心概念"><a href="#Prometheus-核心概念" class="headerlink" title="Prometheus 核心概念"></a>Prometheus 核心概念</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Prometheus 从根本上存储的所有数据都是时间序列数据（Time Serie Data，简称时序数据）。时序数据是具有时间戳的数据流，该数据流属于某个度量指标（Metric）和该度量指标下的多个标签（Label）。除了提供存储功能，Prometheus 还可以利用查询表达式来执行非常 灵活和复杂的查询。</p><h3 id="度量指标和标签"><a href="#度量指标和标签" class="headerlink" title="度量指标和标签"></a>度量指标和标签</h3><p>每个时间序列（Time Serie，简称时序）由度量指标和一组标签键值对唯一确定。</p><p>度量指标名称描述了被监控系统的某个测量特征（比如 http_requests_total 表示 http 请求总数）。度量指标名称由 ASCII 字母、数字、下划线和冒号组成，须匹配正则表达式 [a-zA-Z_:][a-zA-Z0-9_:]*。</p><p>标签开启了 Prometheus 的多维数据模型。对于同一个度量指标，不同标签值组合会形成特定维度的时序。Prometheus 的查询语言可以通过度量指标和标签对时序数据进行过滤和聚合。改变任何度量指标上的任何标签值，都会形成新的时序。标签名称可以包含 ASCII 字母、数字和下划线，须匹配正则表达式 [a-zA-Z_][a-zA-Z0-9_]*，带有 _ 下划线的标签名称保留为内部使用。标签值可以包含任意 Unicode 字符，包括中文。</p><h3 id="采样值（Sample）"><a href="#采样值（Sample）" class="headerlink" title="采样值（Sample）"></a>采样值（Sample）</h3><p>时序数据其实就是一系列采样值。每个采样值包括：</p><ul><li>一个 64 位的浮点数值</li><li>一个精确到毫秒的时间戳</li></ul><h3 id="注解（Notation）"><a href="#注解（Notation）" class="headerlink" title="注解（Notation）"></a>注解（Notation）</h3><p>一个注解由一个度量指标和一组标签键值对构成。形式如下：</p><p>[metric name]{[label name]=[label value], …}<br>例如，度量指标为 api_http_requests_total，标签为 method=”POST”、handler=”/messages” 的注解表示如下：</p><p>api_http_requests_total{method=”POST”, handler=”/messages”}</p><h3 id="度量指标类型"><a href="#度量指标类型" class="headerlink" title="度量指标类型"></a>度量指标类型</h3><p>Prometheus 里的度量指标有以下几种类型。</p><h4 id="计数器（Counter）"><a href="#计数器（Counter）" class="headerlink" title="计数器（Counter）"></a>计数器（Counter）</h4><p>计数器是一种累计 型的度量指标，它是一个只能递增的数值。计数器主要用于统计类似于服务请求数、任务完成数和错误出现次数这样的数据。</p><h4 id="计量器（Gauge）"><a href="#计量器（Gauge）" class="headerlink" title="计量器（Gauge）"></a>计量器（Gauge）</h4><p>计量器表示一个既可以增加, 又可以减少的度量指标值。计量器主要用于测量类似于温度、内存使用量这样的瞬时数据。</p><h4 id="直方图（Histogram）"><a href="#直方图（Histogram）" class="headerlink" title="直方图（Histogram）"></a>直方图（Histogram）</h4><p>直方图对观察结果（通常是请求持续时间或者响应大小这样的数据）进行采样，并在可配置的桶中对其进行统计。有以下几种方式来产生直方图（假设度量指标为 \<basename>）：</basename></p><p>按桶计数，相当于 <basename>_bucket{le=”<upper inclusive bound>“}<br>采样值总和，相当于 <basename>_sum<br>采样值总数，相当于 <basename>_count ，也等同于把所有采样值放到一个桶里来计数 <basename>_bucket{le=”+Inf”}</basename></basename></basename></upper></basename></p><h4 id="汇总（Summary）"><a href="#汇总（Summary）" class="headerlink" title="汇总（Summary）"></a>汇总（Summary）</h4><p>类似于直方图，汇总也对观察结果进行采样。除了可以统计采样值总和和总数，它还能够按分位数 统计。有以下几种方式来产生汇总（假设度量指标为 \<basename>）：</basename></p><p>按分位数，也就是采样值小于该分位数的个数占总数的比例小于 φ，相当于 <basename>{quantile=”&lt;φ&gt;”}<br>采样值总和，相当于 <basename>_sum<br>采样值总数，相当于 <basename>_count</basename></basename></basename></p><h2 id="任务（Job）和实例（Instance）"><a href="#任务（Job）和实例（Instance）" class="headerlink" title="任务（Job）和实例（Instance）"></a>任务（Job）和实例（Instance）</h2><p>在 Prometheus 里，可以从中抓取采样值的端点称为实例，为了性能扩展而复制出来的多个这样的实例形成了一个任务。</p><p>例如下面的 api-server 任务有四个相同的实例：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">job: api-server<br>instance 1: 1.2.3.4:5670<br>instance 2: 1.2.3.4:5671<br>instance 3: 5.6.7.8:5670<br>instance 4: 5.6.7.8:5671<br></code></pre></td></tr></table></figure></p><p>Prometheus 抓取完采样值后，会自动给采样值添加下面的标签和值：</p><p>job:抓取所属任务。<br>instance: 抓取来源实例</p><p>另外每次抓取时，Prometheus 还会自动在以下时序里插入采样值：</p><p>up{job=”[job-name]”, instance=”instance-id”}：<br>采样值为 1 表示实例健康，否则为不健康</p><p>scrape_duration_seconds{job=”[job-name]”, instance=”[instance-id]”}：<br>采样值为本次抓取消耗时间</p><p>scrape_samples_post_metric_relabeling{job=”<job-name>“, instance=”<instance-id>“}：<br>采样值为重新 打标签后的采样值个数</instance-id></job-name></p><p>scrape_samples_scraped{job=”<job-name>“, instance=”<instance-id>“}：<br>采样值 为本次抓取到的采样值个数</instance-id></job-name></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 监控 </category>
          
          <category> Prometheus </category>
          
          <category> 概要 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
